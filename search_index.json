[["index.html", "Malaria vaccine antigen identification for Plasmodium falciparum Preface", " Malaria vaccine antigen identification for Plasmodium falciparum 2023-04-25 Preface The research aims to identify and prioritize previously unknown vaccine antigen candidates with potentially high efficacy against the most prevalent malaria parasite Plasmodium falciparum. Positive-unlabeled random forest (PURF) was applied to learn from the small set of known Plasmodium falciparum antigens and the other proteins with unknown antigenic properties. The research notebook contains data and code generated in the study “Positive-unlabeled learning identifies vaccine candidate antigens in the malaria parasite Plasmodium falciparum.” The notebook also includes instructions on installing the PURF package, retrieving protein variables and assembling machine learning input from the database, as well as code for experimental analysis and plotting. The notebook is licensed under the Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License. "],["id_01_data_engineering.html", "Section 1 Data engineering 1.1 purf package installization 1.2 Retrieving P. falciparum protein variables 1.3 Generating ML input", " Section 1 Data engineering 1.1 purf package installization purf is a Python package that adapts the ensemble and tree modules from scikit-learn (version 0.24.2). The package implements and modifies the positive-unlabeled random forest (PURF) algorithm proposed by Li and Hua (Li and Hua 2014; Denis, Gilleron, and Letouzey 2005; De Comité et al. 1999). In bash: Create and activate Conda environment conda create -n purf scikit-learn=0.24.2 numpy=1.19.0 cython=0.29.21 pandas=1.3.2 conda activate purf Download package cd purf Install package python setup.py install 1.2 Retrieving P. falciparum protein variables In bash: echo &quot;create database pf_reverse_vaccinology&quot; | mariadb -u &lt;dbuser&gt; -p mariadb -u &lt;dbuser&gt; -p pf_reverse_vaccinology &lt; ./data/supplementary_data_1_pf_reverse_vaccinology.sql Overall database schema: Detailed database structure: In R: library(RMariaDB) library(DBI) library(rlist) output_path &lt;- &quot;./other_data/pf_assembled_data.csv&quot; db &lt;- dbConnect(RMariaDB::MariaDB(), user = &quot;root&quot;, password = &quot;&quot;, dbname = &quot;pf_reverse_vaccinology&quot;) get_data &lt;- function(table_name, db) { sql &lt;- sqlInterpolate(db, &quot;SELECT * FROM ?table&quot;, table = dbQuoteIdentifier(db, table_name)) return(subset(dbGetQuery(db, sql), select = -c(id))) } # protein ID and transcript ID map table id_map &lt;- dbGetQuery(db, &#39;SELECT dbxref_1.accession AS accession, dbxref_1.dbxref_id AS protein_id FROM dbxref AS dbxref_1 LEFT OUTER JOIN feature AS feature_1 ON dbxref_1.dbxref_id = feature_1.dbxref_id LEFT OUTER JOIN cvterm ON feature_1.type_id = cvterm.cvterm_id LEFT OUTER JOIN feature_relationship ON feature_1.feature_id = feature_relationship.subject_id LEFT OUTER JOIN feature AS feature_2 ON feature_relationship.object_id = feature_2.feature_id LEFT OUTER JOIN dbxref AS dbxref_2 ON feature_2.dbxref_id = dbxref_2.dbxref_id LEFT OUTER JOIN organism ON feature_1.organism_id = organism.organism_id WHERE feature_1.is_obsolete = 0 AND cvterm.name = &quot;polypeptide&quot; AND organism.species=&quot;falciparum_3D7&quot;&#39;) 1.2.1 Immunological data sets In R: immu &lt;- list() # predivac_processed result for T-cell epitopes immu &lt;- list.append(immu, get_data(&quot;predivac_processed&quot;, db)) # bepipred_2_0 result for B-cell epitopes immu &lt;- list.append(immu, get_data(&quot;bepipred_2_0_processed&quot;, db)) # bepipred_1_0 result for B-cell epitopes immu &lt;- list.append(immu, get_data(&quot;bepipred_1_0_processed&quot;, db)) # abcpred result for B-cell epitopes immu &lt;- list.append(immu, get_data(&quot;abcpred_processed&quot;, db)) # ctlpred result for cytotoxic T-cell epitopes immu &lt;- list.append(immu, get_data(&quot;ctlpred_processed&quot;, db)) # il_10pred result for interleukine-10 inducing epitopes immu &lt;- list.append(immu, get_data(&quot;il_10pred_processed&quot;, db)) # ifnepitope result for IFN-gamma inducing epitopes immu &lt;- list.append(immu, get_data(&quot;ifnepitope_processed&quot;, db)) # tappred for high binding affinity epitopes toward the TAP transporter immu &lt;- list.append(immu, get_data(&quot;tappred_processed&quot;, db)) # mhc_i for MHC class I epitopes immu &lt;- list.append(immu, get_data(&quot;mhc_i&quot;, db)) # mhc_ii for MHC class II epitopes immu &lt;- list.append(immu, get_data(&quot;mhc_ii&quot;, db)) # antigenicity immu &lt;- list.append(immu, get_data(&quot;antigenicity&quot;, db)) # immunogenicity immu &lt;- list.append(immu, get_data(&quot;immunogenicity&quot;, db)) # merge immunological data sets immunological_ds &lt;- id_map[&quot;protein_id&quot;] for (ds in immu) { immunological_ds &lt;- merge(x = immunological_ds, y = ds, by = &quot;protein_id&quot;, all.x = TRUE) } 1.2.2 Proteomic data sets In R: pro &lt;- list() # cello result for subcellualr localization pro &lt;- list.append(pro, subset(get_data(&quot;cello&quot;, db), select = -c(location_id))) # maap result for malaria adhesin/adhesin-like proteins pro &lt;- list.append(pro, get_data(&quot;maap&quot;, db)) # peptides result for physicochemical properties pro &lt;- list.append(pro, get_data(&quot;r_peptides&quot;, db)) # protr result for physicochemical properties pro &lt;- list.append(pro, get_data(&quot;protr&quot;, db)) # hydrophilicity pro &lt;- list.append(pro, get_data(&quot;hydrophilicity&quot;, db)) # predgpi result for gpi anchors prediction pro &lt;- list.append(pro, get_data(&quot;predgpi&quot;, db)) # signalp result for signal cleavage prediction pro &lt;- list.append(pro, subset(get_data(&quot;signalp&quot;, db), select = -c(is_secprotein, cleavage_site, cs_probability))) # abpred results for amino acid compositions and other variables pro &lt;- list.append(pro, get_data(&quot;abpred&quot;, db)) # glycoep results for N-linked and O-linked glycosylation pro &lt;- list.append(pro, get_data(&quot;glycoep_processed&quot;, db)) # blastp result for similarity to human proteins pro &lt;- list.append(pro, get_data(&quot;blastp&quot;, db)) # merge proteomic data sets proteomic_ds &lt;- id_map[&quot;protein_id&quot;] for (ds in pro) { proteomic_ds &lt;- merge(x = proteomic_ds, y = ds, by = &quot;protein_id&quot;, all.x = TRUE) } 1.2.3 Structural data sets In R: struc &lt;- list() # tmhmm result for transmembrane helices prediction struc &lt;- list.append(struc, get_data(&quot;tmhmm_processed&quot;, db)) # seg result for sequence complexity struc &lt;- list.append(struc, get_data(&quot;seg&quot;, db)) # seg + tmhmm result struc &lt;- list.append(struc, get_data(&quot;seg_processed&quot;, db)) # b_cell_epitope_methods for structural predictions struc &lt;- list.append(struc, get_data(&quot;beta_turn&quot;, db)) struc &lt;- list.append(struc, get_data(&quot;surface_accessibility&quot;, db)) struc &lt;- list.append(struc, get_data(&quot;flexibility&quot;, db)) # merge structural analysis data sets structural_ds &lt;- id_map[&quot;protein_id&quot;] for (ds in struc) { structural_ds &lt;- merge(x = structural_ds, y = ds, by = &quot;protein_id&quot;, all.x = TRUE) } 1.2.4 Genomic data sets In R: geno &lt;- list() # snp result geno &lt;- list.append(geno, get_data(&quot;snp&quot;, db)) # merge structural analysis data sets genomic_ds &lt;- id_map[&quot;protein_id&quot;] for (ds in geno) { genomic_ds &lt;- merge(x = genomic_ds, y = ds, by = &quot;protein_id&quot;, all.x = TRUE) } 1.2.5 Final assembly In R: # prepare predictor variables data &lt;- merge(x = immunological_ds, y = proteomic_ds, by = &quot;protein_id&quot;, all = FALSE) data &lt;- merge(x = data, y = structural_ds, by = &quot;protein_id&quot;, all = FALSE) data &lt;- merge(x = data, y = genomic_ds, by = &quot;protein_id&quot;, all = FALSE) data &lt;- merge(x = id_map, y = data, by = &quot;protein_id&quot;, all.x = TRUE) accession &lt;- data$accession data &lt;- subset(data, select = -c(protein_id, accession)) rownames(data) &lt;- accession # write to output write.csv(data, output_path) # close database connection dbDisconnect(db) 1.3 Generating ML input In R: response_var &lt;- read.csv(&quot;./other_data/pf_antigen_labels.csv&quot;, row.names = 1) predictor_vars &lt;- read.csv(&quot;./other_data/pf_assembled_data.csv&quot;, row.names = 1) ml_input &lt;- merge(x = response_var, y = predictor_vars, by = &quot;row.names&quot;, all = TRUE) row_names &lt;- ml_input$Row.names ml_input &lt;- subset(ml_input, select = -c(Row.names)) rownames(ml_input) &lt;- row_names # write to output write.csv(ml_input, &quot;./data/supplementary_data_3_pf_ml_input.csv&quot;) sessionInfo() ## R version 4.2.3 (2023-03-15) ## Platform: x86_64-apple-darwin17.0 (64-bit) ## Running under: macOS Big Sur ... 10.16 ## ## Matrix products: default ## BLAS: /Library/Frameworks/R.framework/Versions/4.2/Resources/lib/libRblas.0.dylib ## LAPACK: /Library/Frameworks/R.framework/Versions/4.2/Resources/lib/libRlapack.dylib ## ## locale: ## [1] en_US.UTF-8/en_US.UTF-8/en_US.UTF-8/C/en_US.UTF-8/en_US.UTF-8 ## ## attached base packages: ## [1] stats graphics grDevices utils datasets methods base ## ## other attached packages: ## [1] rlist_0.4.6.2 DBI_1.1.3 RMariaDB_1.2.2 ## ## loaded via a namespace (and not attached): ## [1] Rcpp_1.0.9 bslib_0.4.0 compiler_4.2.3 jquerylib_0.1.4 ## [5] highr_0.9 R.methodsS3_1.8.2 R.utils_2.12.0 tools_4.2.3 ## [9] digest_0.6.29 bit_4.0.4 jsonlite_1.8.0 evaluate_0.16 ## [13] lifecycle_1.0.3 R.cache_0.16.0 pkgconfig_2.0.3 rlang_1.1.0 ## [17] cli_3.6.1 rstudioapi_0.14 yaml_2.3.5 xfun_0.32 ## [21] fastmap_1.1.0 styler_1.8.0 stringr_1.4.1 knitr_1.40 ## [25] sass_0.4.2 vctrs_0.6.2 hms_1.1.2 bit64_4.0.5 ## [29] data.table_1.14.2 R6_2.5.1 rmarkdown_2.16 bookdown_0.28 ## [33] purrr_0.3.4 magrittr_2.0.3 codetools_0.2-19 htmltools_0.5.3 ## [37] ellipsis_0.3.2 stringi_1.7.8 cachem_1.0.6 R.oo_1.25.0 References "],["id_02_model_training.html", "Section 2 Model training 2.1 Simulation experiment with 99% unlabeled data set. 2.2 Hyper-parameter tuning for PURF 2.3 Variable space weighting", " Section 2 Model training 2.1 Simulation experiment with 99% unlabeled data set. 2.1.1 Analysis In Python: from sklearn.datasets import make_classification import pandas as pd from sklearn.ensemble import RandomForestClassifier import numpy as np from sklearn.impute import SimpleImputer from sklearn.preprocessing import MinMaxScaler from scipy.spatial import distance from purf.pu_ensemble import PURandomForestClassifier import pickle import os import re import session_info X_list = [] y_list = [] for i in range(5): X, y = make_classification( n_samples = 5000, n_features = 300, n_informative = 250, n_redundant = 40, n_repeated = 10, n_classes = 2, n_clusters_per_class = 1, class_sep = 2, random_state = i+1) X = pd.DataFrame(X) # Check the contents of the set print(&#39;%d data points and %d features&#39; % (X.shape)) print(&#39;%d positive out of %d total&#39; % (sum(y), len(y))) X_list.append(X) y_list.append(y) y_orig_list = [] res_ = pd.DataFrame({&#39;index&#39; : range(5000)}) i = 0 for X, y in zip(X_list, y_list): res_[&#39;label_&#39; + str(i + 1)] = y # Convert to positive-unlabeled data where labeled positives are conditionally randomly selected rf = RandomForestClassifier( n_estimators = 1000, max_samples = min(sum(y==0), sum(y==1)), oob_score = True, n_jobs = -1, random_state = 30 ) rf.fit(X, y) res_[&#39;rf_&#39; + str(i + 1)] = rf.oob_decision_function_[:,1] # Keep the original targets safe for later usage y_orig = y.copy() y_orig_list.append(y_orig) # 99% unlabeled np.random.seed(0) y[np.random.choice(np.where((res_[&#39;label_&#39; + str(i + 1)] == 1))[0], replace=False, size=50)] = 2 y[y == 1] = 0 y[y == 2] = 1 res_[&#39;pu_label_&#39; + str(i + 1)] = y # Check the new contents of the set print(&#39;%d positive out of %d total&#39; % (sum(y), len(y))) y_list[i] = y i += 1 res_.to_csv(&#39;./other_data/simulation_labels.csv&#39;) def train_purf(features, outcome, res_path, pickle_path=&#39;./tmp.pkl&#39;, pos_level=0.5, save_model=False): # Imputation imputer = SimpleImputer(strategy=&#39;median&#39;) X = imputer.fit_transform(features) X = pd.DataFrame(X, index=features.index, columns=features.columns) y = outcome features = X # Training PURF purf = PURandomForestClassifier( n_estimators = 10000, oob_score = True, n_jobs = -1, random_state = 42, pos_level = pos_level ) purf.fit(X, y) # Storing results res = pd.DataFrame({&#39;protein_id&#39;: X.index, &#39;antigen_label&#39; : y}) res[&#39;OOB score&#39;] = purf.oob_decision_function_[:,1] res = res.groupby(&#39;protein_id&#39;).mean().merge(features, left_index=True, right_index=True) res.to_csv(res_path) if save_model is True: with open(pickle_path, &#39;wb&#39;) as out: pickle.dump(purf, out, pickle.HIGHEST_PROTOCOL) i = 0 for X, y in zip(X_list, y_list): train_purf(X, y, res_path=&#39;./other_data/simulation_res_&#39; + str(i + 1) + &#39;.csv&#39;) i += 1 2.1.2 Plotting In R: library(rlist) library(pROC) library(mixR) library(pracma) library(reshape2) library(ggplot2) library(ggpubr) library(rstatix) library(cowplot) labels &lt;- read.csv(&quot;./other_data/simulation_labels.csv&quot;) tmp &lt;- data.frame(sapply(1:5, function(i) read.csv(paste0(&quot;./other_data/simulation_res_&quot;, i, &quot;.csv&quot;), check.names = FALSE)[, &quot;OOB score&quot;, drop = FALSE])) colnames(tmp) &lt;- sapply(1:5, function(i) paste0(&quot;OOB_score_&quot;, i)) data &lt;- cbind(tmp, labels[, c( sapply(1:5, function(i) paste0(&quot;label_&quot;, i)), sapply(1:5, function(i) paste0(&quot;pu_label_&quot;, i)) )]) roc_true_labels &lt;- list() auroc_true_labels &lt;- c() for (i in 1:5) { roc_ &lt;- roc(response = data[, paste0(&quot;label_&quot;, i)], predictor = data[, paste0(&quot;OOB_score_&quot;, i)]) roc_true_labels &lt;- list.append(roc_true_labels, data.frame(fpr = 1 - roc_$specificities, tpr = roc_$sensitivities)) auroc_true_labels &lt;- c(auroc_true_labels, as.numeric(roc_$auc)) } roc_pu_labels &lt;- list() auroc_pu_labels &lt;- c() for (i in 1:5) { roc_ &lt;- roc(response = data[, paste0(&quot;pu_label_&quot;, i)], predictor = data[, paste0(&quot;OOB_score_&quot;, i)]) roc_pu_labels &lt;- list.append(roc_pu_labels, data.frame(fpr = 1 - roc_$specificities, tpr = roc_$sensitivities)) auroc_pu_labels &lt;- c(auroc_pu_labels, as.numeric(roc_$auc)) } roc_estimated &lt;- list() auroc_estimated &lt;- c() for (i in 1:5) { fit &lt;- mixfit(data[, paste0(&quot;OOB_score_&quot;, i)], ncomp = 2) # Calculate receiver operating characteristic (ROC) curve # for putative positive and negative samples x &lt;- seq(-0.5, 1.5, by = 0.01) neg_cum &lt;- pnorm(x, mean = fit$mu[1], sd = fit$sd[1]) pos_cum &lt;- pnorm(x, mean = fit$mu[2], sd = fit$sd[2]) fpr &lt;- (1 - neg_cum) / ((1 - neg_cum) + neg_cum) # false positive / (false positive + true negative) tpr &lt;- (1 - pos_cum) / ((1 - pos_cum) + pos_cum) # true positive / (true positive + false negative) roc_estimated &lt;- list.append(roc_estimated, data.frame(fpr = fpr, tpr = tpr)) auroc_estimated &lt;- c(auroc_estimated, as.numeric(trapz(-fpr, tpr))) } sem &lt;- function(x, na.rm = TRUE) sd(x, na.rm) / sqrt(length(na.omit(x))) ds &lt;- rbind( do.call(rbind, roc_true_labels), do.call(rbind, roc_pu_labels), do.call(rbind, roc_estimated) ) ds$group &lt;- c( do.call(&quot;c&quot;, sapply(1:5, function(i) rep(paste(&quot;True labels&quot;), nrow(roc_true_labels[[i]])))), do.call(&quot;c&quot;, sapply(1:5, function(i) rep(paste(&quot;PU labels&quot;), nrow(roc_pu_labels[[i]])))), melt(sapply(1:5, function(i) rep(paste(&quot;Estimated&quot;), nrow(roc_estimated[[i]]))))$value ) ds$group &lt;- factor(ds$group) ds$sub_group &lt;- c( do.call(&quot;c&quot;, sapply(1:5, function(i) rep(paste(&quot;True labels&quot;, i), nrow(roc_true_labels[[i]])))), do.call(&quot;c&quot;, sapply(1:5, function(i) rep(paste(&quot;PU labels&quot;, i), nrow(roc_pu_labels[[i]])))), melt(sapply(1:5, function(i) rep(paste(&quot;Estimated&quot;, i), nrow(roc_estimated[[i]]))))$value ) ds$sub_group &lt;- factor(ds$sub_group) p1 &lt;- ggplot(ds, aes(x = fpr, y = tpr, colour = group, group = sub_group)) + geom_line(size = 0.2) + scale_colour_manual( values = c(&quot;#E41A1C&quot;, &quot;#377EB8&quot;, &quot;#4DAF4A&quot;), breaks = c(&quot;Estimated&quot;, &quot;True labels&quot;, &quot;PU labels&quot;), labels = c( paste0( &quot;Estimated (AUROC = &quot;, round(mean(auroc_estimated), 3), &quot; ± &quot;, round(sem(auroc_estimated), 3), &quot;)&quot; ), paste0( &quot;True labels (AUROC = &quot;, round(mean(auroc_true_labels), 3), &quot; ± &quot;, round(sem(auroc_true_labels), 3), &quot;)&quot; ), paste0( &quot;PU labels (AUROC = &quot;, round(mean(auroc_pu_labels), 3), &quot; ± &quot;, round(sem(auroc_pu_labels), 3), &quot;)&quot; ) ) ) + theme_bw() + theme( panel.grid.major = element_blank(), panel.grid.minor = element_blank(), axis.title = element_text(colour = &quot;black&quot;), axis.text = element_text(colour = &quot;black&quot;), plot.title = element_text(hjust = 0.5, colour = &quot;black&quot;), plot.margin = ggplot2::margin(5, 5, 5, 5, &quot;pt&quot;), legend.title = element_blank(), legend.text = element_text(colour = &quot;black&quot;), legend.position = c(0.6, 0.2), legend.background = element_blank() ) + xlab(&quot;False positive rate&quot;) + ylab(&quot;True positive rate&quot;) ds &lt;- data.frame(&quot;AUROC&quot; = c(auroc_true_labels, auroc_pu_labels, auroc_estimated)) ds$group &lt;- c( rep(&quot;True labels&quot;, length(auroc_true_labels)), rep(&quot;PU labels&quot;, length(auroc_pu_labels)), rep(&quot;Estimated&quot;, length(auroc_estimated)) ) ds$group &lt;- factor(ds$group, levels = c(&quot;Estimated&quot;, &quot;True labels&quot;, &quot;PU labels&quot;)) stats &lt;- wilcox_test(ds, AUROC ~ group, p.adjust.method = &quot;BH&quot;) stats &lt;- stats %&gt;% add_xy_position(fun = &quot;mean_se&quot;, x = &quot;group&quot;) p2 &lt;- ggbarplot(ds, x = &quot;group&quot;, y = &quot;AUROC&quot;, add = &quot;mean_se&quot;, fill = &quot;group&quot;, alpha = 0.2, size = 0.3, add.params = list(size = 0.3) ) + scale_colour_manual( values = c(&quot;#E41A1C&quot;, &quot;#377EB8&quot;, &quot;#4DAF4A&quot;), breaks = c(&quot;Estimated&quot;, &quot;True labels&quot;, &quot;PU labels&quot;) ) + stat_pvalue_manual(stats, label = &quot;p = {p.adj}&quot;, size = 3) + theme_bw() + theme( panel.grid.major = element_blank(), panel.grid.minor = element_blank(), axis.title = element_text(colour = &quot;black&quot;), axis.text = element_text(colour = &quot;black&quot;), plot.title = element_text(hjust = 0.5, colour = &quot;black&quot;), plot.margin = ggplot2::margin(5, 5, 5, 5, &quot;pt&quot;), legend.title = element_blank(), legend.text = element_text(colour = &quot;black&quot;), legend.position = &quot;none&quot;, legend.background = element_blank() ) + xlab(&quot;&quot;) Final plot p_combined &lt;- plot_grid(p1, p2, nrow = 1, labels = c(&quot;a&quot;, &quot;b&quot;)) p_combined 2.2 Hyper-parameter tuning for PURF 2.2.1 Analysis In Python: import pandas as pd import numpy as np from sklearn.impute import SimpleImputer from sklearn.preprocessing import MinMaxScaler from scipy.spatial import distance from purf.pu_ensemble import PURandomForestClassifier import pickle import os import re # input set (5393, 1 + 272) data = pd.read_csv(&#39;./data/supplementary_data_3_pf_ml_input.csv&#39;, index_col=0) pf3d7_features = data.iloc[:,1:] pf3d7_outcome = np.array(data.antigen_label) def train_purf(features, outcome, pos_level, res_path, pickle_path): # Imputation imputer = SimpleImputer(strategy=&#39;median&#39;) X = imputer.fit_transform(features) X = pd.DataFrame(X, index=features.index, columns=features.columns) y = outcome features = X # Training PURF purf = PURandomForestClassifier( n_estimators = 100000, oob_score = True, n_jobs = 64, random_state = 42, pos_level = pos_level ) purf.fit(X, y) # Storing results res = pd.DataFrame({&#39;protein_id&#39;: X.index, &#39;antigen_label&#39;: y}) res[&#39;OOB score&#39;] = purf.oob_decision_function_[:,1] res = res.groupby(&#39;protein_id&#39;).mean().merge(features, left_index=True, right_on=&#39;protein_id&#39;) res = res[[&#39;antigen_label&#39;, &#39;OOB score&#39;]] features.to_csv(res_path, sep=&#39;\\t&#39;) with open(pickle_path, &#39;wb&#39;) as out: pickle.dump(purf, out, pickle.HIGHEST_PROTOCOL) for pos_level in [0.5, 0.4, 0.6, 0.3, 0.7, 0.2, 0.8, 0.1, 0.9]: train_purf(pf3d7_features, pf3d7_outcome, pos_level=pos_level, res_path=&#39;~/Downloads/pos_level/without_weighting/%.1f_res.tsv&#39; % pos_level, pickle_path=&#39;~/Downloads/pos_level/without_weighting/%.1f_purf.pkl&#39; % pos_level) dir = &#39;~/Downloads/pos_level/without_wighting/&#39; files = os.listdir(dir) tmp = pd.read_csv(dir + &#39;0.1_res.tsv&#39;, sep=&#39;\\t&#39;, index_col=0)[&#39;antigen_label&#39;] data_frames = [pd.read_csv(dir + &#39;%.1f_res.tsv&#39; % pos_level, sep=&#39;\\t&#39;, index_col=0)[&#39;OOB scores&#39;] for pos_level in np.arange(0.1, 1, 0.1)] merged_df = pd.concat([tmp] + data_frames, join=&#39;outer&#39;, axis=1) colnames = [&#39;antigen_label&#39;] + [&#39;%.1f&#39; % pos_level for pos_level in np.arange(0.1, 1, 0.1)] merged_df.columns = colnames merged_df.to_csv(&#39;./other_data/pos_level_parameter_tuning_wo_weighting.csv&#39;) 2.2.2 Plotting In R: library(mixR) library(pracma) library(rlist) library(ggplot2) library(cowplot) library(grid) library(gridExtra) data &lt;- read.csv(&quot;./other_data/pos_level_parameter_tuning_wo_weighting.csv&quot;, header = TRUE, row.names = 1, check.names = FALSE) # Extract data with only unlabeled proteins data_unl &lt;- data[data$antigen_label == 0, ] plot_list &lt;- list() plot_list2 &lt;- list() for (i in seq(0.1, 0.9, 0.1)) { fit &lt;- mixfit(data_unl[[as.character(i)]], ncomp = 2) # Calculate receiver operating characteristic (ROC) curve # for putative positive and negative samples x &lt;- seq(-0.5, 1.5, by = 0.01) neg_cum &lt;- pnorm(x, mean = fit$mu[1], sd = fit$sd[1]) pos_cum &lt;- pnorm(x, mean = fit$mu[2], sd = fit$sd[2]) fpr &lt;- (1 - neg_cum) / ((1 - neg_cum) + neg_cum) # false positive / (false positive + true negative) tpr &lt;- (1 - pos_cum) / ((1 - pos_cum) + pos_cum) # true positive / (true positive + false negative) p &lt;- plot(fit, title = paste0( &quot;Positive level = &quot;, i, &quot; (AUROC = &quot;, round(trapz(-fpr, tpr), 2), &quot;)&quot; )) + scale_fill_manual(values = c(&quot;blue&quot;, &quot;red&quot;), labels = c(&quot;Putative negative&quot;, &quot;Putative positive&quot;)) + theme_bw() + { if (i == 0.1) { theme( panel.grid.major = element_blank(), panel.grid.minor = element_blank(), axis.title = element_blank(), axis.text = element_text(colour = &quot;black&quot;), plot.title = element_text(hjust = 0.5, colour = &quot;black&quot;), legend.title = element_blank(), legend.text = element_text(colour = &quot;black&quot;), legend.position = c(0.7, 0.85), legend.background = element_blank() ) } else { theme( panel.grid.major = element_blank(), panel.grid.minor = element_blank(), axis.title = element_blank(), axis.text = element_text(colour = &quot;black&quot;), plot.title = element_text(hjust = 0.5, colour = &quot;black&quot;), legend.position = &quot;none&quot; ) } } + xlim(-0.8, 1.5) # Calculate percent rank for labeled positives data_ &lt;- data[c(&quot;antigen_label&quot;, as.character(i))] colnames(data_) &lt;- c(&quot;antigen_label&quot;, &quot;OOB score&quot;) data_$percent_rank &lt;- rank(data_[[&quot;OOB score&quot;]]) / nrow(data) data_ &lt;- data_[data$antigen_label == 1, ] data_ &lt;- data_[order(-data_$percent_rank), ] data_$x &lt;- 1:nrow(data_) / nrow(data_) cat(paste0(&quot;EPR: &quot;, sum(data_$`OOB score` &gt;= 0.5) / nrow(data_), &quot;\\n&quot;)) p2 &lt;- ggplot(data_, aes(x = x, y = `percent_rank`)) + geom_hline(yintercept = 0.5, linetype = &quot;dashed&quot;, color = &quot;black&quot;) + geom_line() + geom_point(aes(color = `OOB score`), size = 1) + scale_colour_gradient2(low = &quot;blue&quot;, mid = &quot;purple&quot;, high = &quot;red&quot;, midpoint = 0.5, limits = c(0, 1)) + theme_bw() + { if (i == 0.1) { theme( panel.grid.major = element_blank(), panel.grid.minor = element_blank(), axis.title = element_blank(), axis.text = element_text(colour = &quot;black&quot;), plot.title = element_text(hjust = 0.5, colour = &quot;black&quot;), legend.title = element_text(hjust = 0.5, colour = &quot;black&quot;, angle = 0), legend.text = element_text(colour = &quot;black&quot;), legend.position = c(0.4, 0.15), legend.background = element_blank() ) } else { theme( panel.grid.major = element_blank(), panel.grid.minor = element_blank(), axis.title = element_blank(), axis.text = element_text(colour = &quot;black&quot;), plot.title = element_text(hjust = 0.5, colour = &quot;black&quot;), legend.position = &quot;none&quot; ) } } + { if (i == 0.1) { guides(colour = guide_colourbar(title.position = &quot;top&quot;, direction = &quot;horizontal&quot;)) } } + { if (i == 0.1) { labs(colour = &quot;Score (proportion of votes)&quot;) } } + ggtitle(paste0( &quot;Positive level = &quot;, i, &quot; (AUC = &quot;, round(trapz(c(0, data_$x, 1), c(1, data_$percent_rank, 0)), 2), &quot;)&quot; )) + ylim(0, 1) plot_list &lt;- list.append(plot_list, p) plot_list2 &lt;- list.append(plot_list2, p2) } 2.2.2.1 Bimodal distribution plot x_grob &lt;- textGrob(&quot;Score (proportion of votes)&quot;, gp = gpar(fontsize = 15)) y_grob &lt;- textGrob(&quot;Density&quot;, gp = gpar(fontsize = 15), rot = 90) grid.arrange(arrangeGrob(plot_grid(plotlist = plot_list, ncol = 3), left = y_grob, bottom = x_grob)) 2.2.2.2 Known antigen ranking x_grob2 &lt;- textGrob(&quot;Ranked known antigens (scaled)&quot;, gp = gpar(fontsize = 15)) y_grob2 &lt;- textGrob(&quot;Percent rank&quot;, gp = gpar(fontsize = 15), rot = 90) grid.arrange(arrangeGrob(plot_grid(plotlist = plot_list2, ncol = 3), left = y_grob2, bottom = x_grob2)) 2.3 Variable space weighting 2.3.1 Analysis In Python: from sklearn.datasets import make_classification import pandas as pd from sklearn.ensemble import RandomForestClassifier import numpy as np from sklearn.impute import SimpleImputer from sklearn.preprocessing import MinMaxScaler from scipy.spatial import distance from purf.pu_ensemble import PURandomForestClassifier import pickle import os import re import session_info # input set (5393, 1 + 272) data = pd.read_csv(&#39;./data/supplementary_data_3_pf_ml_input.csv&#39;, index_col=0) pf3d7_features = data.iloc[:,1:] pf3d7_outcome = np.array(data.antigen_label) def train_purf(features, outcome, pos_level, res_path, pickle_path): # Imputation imputer = SimpleImputer(strategy=&#39;median&#39;) X = imputer.fit_transform(features) X = pd.DataFrame(X, index=features.index, columns=features.columns) y = outcome features = X print(&#39;There are %d positives out of %d samples before variable space weighting.&#39; % (sum(y), len(y))) # variable space weighting lab_pos = X.loc[y==1,:] median = np.median(lab_pos, axis=0) # variable space weighting lab_pos = X.loc[y==1,:] median = np.median(lab_pos, axis=0) scaler = MinMaxScaler(feature_range=(1,10)) dist = list() for i in range(lab_pos.shape[0]): dist.append(distance.euclidean(lab_pos.iloc[i, :], median)) dist = np.asarray(dist).reshape(-1, 1) counts = np.round(scaler.fit_transform(dist)) counts = np.array(counts, dtype=np.int64)[:, 0] X_temp = X.iloc[y==1, :] X = X.iloc[y==0, :] y = np.asarray([0] * X.shape[0] + [1] * (sum(counts))) appended_data = [X] for i in range(len(counts)): appended_data.append(pd.concat([X_temp.iloc[[i]]] * counts[i])) X = pd.concat(appended_data) print(&#39;There are %d positives out of %d samples after variable space weighting.&#39; % (sum(y), len(y))) # Training PURF purf = PURandomForestClassifier( n_estimators = 100000, oob_score = True, n_jobs = 64, random_state = 42, pos_level = pos_level ) purf.fit(X, y) # Storing results res = pd.DataFrame({&#39;protein_id&#39;: X.index, &#39;antigen_label&#39;: y}) res[&#39;OOB score&#39;] = purf.oob_decision_function_[:,1] res = res.groupby(&#39;protein_id&#39;).mean().merge(features, left_index=True, right_on=&#39;protein_id&#39;) res = res[[&#39;antigen_label&#39;, &#39;OOB score&#39;]] features.to_csv(res_path, sep=&#39;\\t&#39;) with open(pickle_path, &#39;wb&#39;) as out: pickle.dump(purf, out, pickle.HIGHEST_PROTOCOL) for pos_level in [0.5, 0.4, 0.6, 0.3, 0.7, 0.2, 0.8, 0.1, 0.9]: train_purf(pf3d7_features, pf3d7_outcome, pos_level=pos_level, res_path=&#39;~/Downloads/pos_level/with_weighting/%.1f_res.tsv&#39; % pos_level, pickle_path=&#39;~/Downloads/pos_level/with_weighting/%.1f_purf.pkl&#39; % pos_level) dir = &#39;~/Downloads/pos_level/with_weighting/&#39; files = os.listdir(dir) tmp = pd.read_csv(dir + &#39;0.1_res.tsv&#39;, sep=&#39;\\t&#39;, index_col=0)[&#39;antigen_label&#39;] data_frames = [pd.read_csv(dir + &#39;%.1f_res.tsv&#39; % pos_level, sep=&#39;\\t&#39;, index_col=0)[&#39;OOB scores&#39;] for pos_level in np.arange(0.1, 1, 0.1)] merged_df = pd.concat([tmp] + data_frames, join=&#39;outer&#39;, axis=1) colnames = [&#39;antigen_label&#39;] + [&#39;%.1f&#39; % pos_level for pos_level in np.arange(0.1, 1, 0.1)] merged_df.columns = colnames merged_df.to_csv(&#39;./other_data/pos_level_parameter_tuning_w_weighting.csv&#39;) 2.3.2 Plotting In R: library(mixR) library(pracma) library(rlist) library(ggplot2) library(cowplot) library(grid) library(gridExtra) data &lt;- read.csv(&quot;./other_data/pos_level_parameter_tuning_w_weighting.csv&quot;, header = TRUE, row.names = 1, check.names = FALSE) # Extract data with only unlabeled proteins data_unl &lt;- data[data$antigen_label == 0, ] plot_list &lt;- list() plot_list2 &lt;- list() for (i in seq(0.1, 0.9, 0.1)) { fit &lt;- mixfit(data_unl[[as.character(i)]], ncomp = 2) # Calculate receiver operating characteristic (ROC) curve # for putative positive and negative samples x &lt;- seq(-0.5, 1.5, by = 0.01) neg_cum &lt;- pnorm(x, mean = fit$mu[1], sd = fit$sd[1]) pos_cum &lt;- pnorm(x, mean = fit$mu[2], sd = fit$sd[2]) fpr &lt;- (1 - neg_cum) / ((1 - neg_cum) + neg_cum) # false positive / (false positive + true negative) tpr &lt;- (1 - pos_cum) / ((1 - pos_cum) + pos_cum) # true positive / (true positive + false negative) p &lt;- plot(fit, title = paste0( &quot;Positive level = &quot;, i, &quot; (AUROC = &quot;, round(trapz(-fpr, tpr), 2), &quot;)&quot; )) + scale_fill_manual(values = c(&quot;blue&quot;, &quot;red&quot;), labels = c(&quot;Putative negative&quot;, &quot;Putative positive&quot;)) + theme_bw() + { if (i == 0.1) { theme( panel.grid.major = element_blank(), panel.grid.minor = element_blank(), axis.title = element_blank(), axis.text = element_text(colour = &quot;black&quot;), plot.title = element_text(hjust = 0.5, colour = &quot;black&quot;), legend.title = element_blank(), legend.text = element_text(colour = &quot;black&quot;), legend.position = c(0.7, 0.85), legend.background = element_blank() ) } else { theme( panel.grid.major = element_blank(), panel.grid.minor = element_blank(), axis.title = element_blank(), axis.text = element_text(colour = &quot;black&quot;), plot.title = element_text(hjust = 0.5, colour = &quot;black&quot;), legend.position = &quot;none&quot; ) } } + xlim(-0.8, 1.5) # Calculate percent rank for labeled positives data_ &lt;- data[c(&quot;antigen_label&quot;, as.character(i))] colnames(data_) &lt;- c(&quot;antigen_label&quot;, &quot;OOB score&quot;) data_$percent_rank &lt;- rank(data_[[&quot;OOB score&quot;]]) / nrow(data) data_ &lt;- data_[data$antigen_label == 1, ] data_ &lt;- data_[order(-data_$percent_rank), ] data_$x &lt;- 1:nrow(data_) / nrow(data_) cat(paste0(&quot;EPR: &quot;, sum(data_$`OOB score` &gt;= 0.5) / nrow(data_), &quot;\\n&quot;)) p2 &lt;- ggplot(data_, aes(x = x, y = `percent_rank`)) + geom_hline(yintercept = 0.5, linetype = &quot;dashed&quot;, color = &quot;black&quot;) + geom_line() + geom_point(aes(color = `OOB score`), size = 1) + scale_colour_gradient2(low = &quot;blue&quot;, mid = &quot;purple&quot;, high = &quot;red&quot;, midpoint = 0.5, limits = c(0, 1)) + theme_bw() + { if (i == 0.1) { theme( panel.grid.major = element_blank(), panel.grid.minor = element_blank(), axis.title = element_blank(), axis.text = element_text(colour = &quot;black&quot;), plot.title = element_text(hjust = 0.5, colour = &quot;black&quot;), legend.title = element_text(hjust = 0.5, colour = &quot;black&quot;, angle = 0), legend.text = element_text(colour = &quot;black&quot;), legend.position = c(0.4, 0.15), legend.background = element_blank() ) } else { theme( panel.grid.major = element_blank(), panel.grid.minor = element_blank(), axis.title = element_blank(), axis.text = element_text(colour = &quot;black&quot;), plot.title = element_text(hjust = 0.5, colour = &quot;black&quot;), legend.position = &quot;none&quot; ) } } + { if (i == 0.1) { guides(colour = guide_colourbar(title.position = &quot;top&quot;, direction = &quot;horizontal&quot;)) } } + { if (i == 0.1) { labs(colour = &quot;Score (proportion of votes)&quot;) } } + ggtitle(paste0( &quot;Positive level = &quot;, i, &quot; (AUC = &quot;, round(trapz(c(0, data_$x, 1), c(1, data_$percent_rank, 0)), 2), &quot;)&quot; )) + ylim(0, 1) plot_list &lt;- list.append(plot_list, p) plot_list2 &lt;- list.append(plot_list2, p2) } 2.3.2.1 Bimodal distribution plot x_grob &lt;- textGrob(&quot;Score (proportion of votes)&quot;, gp = gpar(fontsize = 15)) y_grob &lt;- textGrob(&quot;Density&quot;, gp = gpar(fontsize = 15), rot = 90) grid.arrange(arrangeGrob(plot_grid(plotlist = plot_list, ncol = 3), left = y_grob, bottom = x_grob)) 2.3.2.2 Known antigen ranking x_grob2 &lt;- textGrob(&quot;Ranked known antigens (scaled)&quot;, gp = gpar(fontsize = 15)) y_grob2 &lt;- textGrob(&quot;Percent rank&quot;, gp = gpar(fontsize = 15), rot = 90) grid.arrange(arrangeGrob(plot_grid(plotlist = plot_list2, ncol = 3), left = y_grob2, bottom = x_grob2)) sessionInfo() ## R version 4.2.3 (2023-03-15) ## Platform: x86_64-apple-darwin17.0 (64-bit) ## Running under: macOS Big Sur ... 10.16 ## ## Matrix products: default ## BLAS: /Library/Frameworks/R.framework/Versions/4.2/Resources/lib/libRblas.0.dylib ## LAPACK: /Library/Frameworks/R.framework/Versions/4.2/Resources/lib/libRlapack.dylib ## ## locale: ## [1] en_US.UTF-8/en_US.UTF-8/en_US.UTF-8/C/en_US.UTF-8/en_US.UTF-8 ## ## attached base packages: ## [1] grid stats graphics grDevices utils datasets methods ## [8] base ## ## other attached packages: ## [1] gridExtra_2.3 cowplot_1.1.1 rstatix_0.7.0 ggpubr_0.4.0 ggplot2_3.4.2 ## [6] reshape2_1.4.4 pracma_2.3.8 mixR_0.2.0 pROC_1.18.0 rlist_0.4.6.2 ## ## loaded via a namespace (and not attached): ## [1] Rcpp_1.0.9 lattice_0.20-45 tidyr_1.2.0 png_0.1-7 ## [5] assertthat_0.2.1 digest_0.6.29 utf8_1.2.2 R6_2.5.1 ## [9] plyr_1.8.7 backports_1.4.1 evaluate_0.16 highr_0.9 ## [13] pillar_1.8.1 rlang_1.1.0 rstudioapi_0.14 data.table_1.14.2 ## [17] car_3.1-0 jquerylib_0.1.4 R.utils_2.12.0 R.oo_1.25.0 ## [21] Matrix_1.5-3 reticulate_1.25 rmarkdown_2.16 styler_1.8.0 ## [25] stringr_1.4.1 munsell_0.5.0 broom_1.0.0 compiler_4.2.3 ## [29] xfun_0.32 pkgconfig_2.0.3 htmltools_0.5.3 tidyselect_1.1.2 ## [33] tibble_3.1.8 bookdown_0.28 codetools_0.2-19 fansi_1.0.3 ## [37] dplyr_1.0.9 withr_2.5.0 R.methodsS3_1.8.2 jsonlite_1.8.0 ## [41] gtable_0.3.0 lifecycle_1.0.3 DBI_1.1.3 magrittr_2.0.3 ## [45] scales_1.2.1 carData_3.0-5 cli_3.6.1 stringi_1.7.8 ## [49] cachem_1.0.6 ggsignif_0.6.3 bslib_0.4.0 generics_0.1.3 ## [53] vctrs_0.6.2 tools_4.2.3 R.cache_0.16.0 glue_1.6.2 ## [57] purrr_0.3.4 abind_1.4-5 fastmap_1.1.0 yaml_2.3.5 ## [61] colorspace_2.0-3 knitr_1.40 sass_0.4.2 "],["id_03_candidate_prioritization.html", "Section 3 Candidate prioritization 3.1 Jackknife-based validation of PURF models 3.2 Model interpretation", " Section 3 Candidate prioritization 3.1 Jackknife-based validation of PURF models 3.1.1 Analysis In Python: import pandas as pd import numpy as np import pickle from sklearn.impute import SimpleImputer from purf.pu_ensemble import PURandomForestClassifier from sklearn.preprocessing import MinMaxScaler from scipy.spatial import distance from joblib import Parallel, delayed from sklearn.ensemble._forest import _generate_unsampled_indices import os import re import session_info # input set (5393, 1 + 272) data = pd.read_csv(&#39;./data/supplementary_data_3_pf_ml_input.csv&#39;, index_col=0) pf3d7_features = data.iloc[:,1:] pf3d7_outcome = np.array(data.antigen_label) REF_ANTIGENS = {&#39;CSP&#39;: &#39;PF3D7_0304600.1-p1&#39;, &#39;RH5&#39;: &#39;PF3D7_0424100.1-p1&#39;, &#39;MSP5&#39;: &#39;PF3D7_0206900.1-p1&#39;, &#39;P230&#39;: &#39;PF3D7_0209000.1-p1&#39;} # private function for train_purf() def _get_ref_antigen_stats(idx, tree, X, y, ref_indices, max_samples=None): if max_samples is None: max_samples = y.shape[0] oob_indices = _generate_unsampled_indices(tree.random_state, y.shape[0], max_samples) ref_oob = [i in oob_indices for i in ref_indices] ref_pred = list() pred = tree.predict_proba(X[ref_indices,:], check_input=False) ref_pred = pred[:,1] return ref_oob, ref_pred def train_purf(features, outcome, res_path, pickle_path, tree_filtering=None, model_path=None, n_jobs=1): # Imputation imputer = SimpleImputer(strategy=&#39;median&#39;) X = imputer.fit_transform(features) X = pd.DataFrame(X, index=features.index, columns=features.columns) y = outcome features = X print(&#39;There are %d positives out of %d samples before feature space weighting.&#39; % (sum(y), len(y))) # Feature space weighting lab_pos = X.loc[y==1,:] median = np.median(lab_pos, axis=0) # Feature space weighting lab_pos = X.loc[y==1,:] median = np.median(lab_pos, axis=0) scaler = MinMaxScaler(feature_range=(1,10)) dist = list() for i in range(lab_pos.shape[0]): dist.append(distance.euclidean(lab_pos.iloc[i, :], median)) dist = np.asarray(dist).reshape(-1, 1) counts = np.round(scaler.fit_transform(dist)) counts = np.array(counts, dtype=np.int64)[:, 0] X_temp = X.iloc[y==1, :] X = X.iloc[y==0, :] y = np.asarray([0] * X.shape[0] + [1] * (sum(counts))) appended_data = [X] for i in range(len(counts)): appended_data.append(pd.concat([X_temp.iloc[[i]]] * counts[i])) X = pd.concat(appended_data) print(&#39;There are %d positives out of %d samples after feature space weighting.&#39; % (sum(y), len(y))) res = pd.DataFrame({&#39;protein_id&#39;: X.index, &#39;antigen_label&#39; : y}) if tree_filtering is not None: # get ref antigen indices ref_index_dict = {ref:list() for ref in list(REF_ANTIGENS.values())} for i in range(res.shape[0]): if res[&#39;protein_id&#39;][i] in list(REF_ANTIGENS.values()): ref_index_dict[res[&#39;protein_id&#39;][i]].append(res.index[i]) ref_indices = sum(ref_index_dict.values(), []) # get OOB stats and predictions X = X.astype(&#39;float32&#39;) purf = pickle.load(open(model_path, &#39;rb&#39;)) trees = purf.estimators_ idx_list = [i for i in range(len(trees))] stats_res = Parallel(n_jobs=n_jobs)( delayed(_get_ref_antigen_stats)(idx, trees[idx], np.array(X), y, ref_indices) for idx in idx_list) # ref_oob data structure: # rows represent individual trees # column represent reference antigens # cells indicate whether the reference antigen is in the OOB samples of the tree ref_oob = np.array([ref_oob for ref_oob, ref_pred in stats_res]) # ref_pred data structure: # rows represent individual trees # column represent reference antigens # cells indicate the prediction of the reference antigen by the tree ref_pred = np.array([ref_pred for ref_oob, ref_pred in stats_res]) # analyze duplicated reference antigens as a group cumsum_num_ref = np.cumsum(np.array([len(v) for k,v in ref_index_dict.items()])) ref_oob_all = np.array([ref_oob[:, 0:cumsum_num_ref[i]].any(axis=1) if i == 0 else \\ ref_oob[:, cumsum_num_ref[i - 1]:cumsum_num_ref[i]].any(axis=1) \\ for i in range(len(REF_ANTIGENS))]).T ref_pred_all = np.array([ref_pred[:, 0:cumsum_num_ref[i]].any(axis=1) if i == 0 else \\ ref_pred[:, cumsum_num_ref[i - 1]:cumsum_num_ref[i]].sum(axis=1) \\ for i in range(len(REF_ANTIGENS))]).T # calculate number of reference antigens as OOB samples for each tree oob_total = ref_oob_all.sum(axis=1) # assign score of 1 to trees that correctly predict all OOB reference antigens; otherwise, assign 0 score weights = np.zeros(len(trees)) # iterate through the trees and calculate the stats for i in range(len(trees)): oob_list = list(ref_oob_all[i,:]) pred_list = list(ref_pred_all[i,:]) if oob_total[i] == 0: weights[i] = 0 else: if sum(np.array(pred_list)[oob_list] != 0) == oob_total[i]: weights[i] = 1 if tree_filtering is None: # Training PURF purf = PURandomForestClassifier( n_estimators = 100000, oob_score = True, n_jobs = 64, random_state = 42, pos_level = 0.5 ) purf.fit(X, y) else: purf._set_oob_score_with_weights(np.array(X), y.reshape(-1,1), weights=weights) # Storing results res[&#39;OOB score&#39;] = purf.oob_decision_function_[:,1] features = features.merge(res.groupby(&#39;protein_id&#39;).mean(), left_index=True, right_on=&#39;protein_id&#39;) features = features[[&#39;antigen_label&#39;, &#39;OOB score&#39;]] features.to_csv(res_path) if tree_filtering is None: with open(pickle_path, &#39;wb&#39;) as out: pickle.dump(purf, out, pickle.HIGHEST_PROTOCOL) else: with open(pickle_path, &#39;wb&#39;) as out: pickle.dump({&#39;model&#39;: purf, &#39;weights&#39;: weights}, out, pickle.HIGHEST_PROTOCOL) 3.1.1.1 Training on whole data set In Python: train_purf(pf3d7_features, pf3d7_outcome, res_path=&#39;~/Downloads/pos_level/0.5_res_tree_filtering.csv&#39;, pickle_path=&#39;~/Downloads/pos_level/0.5_purf_tree_filtering.pkl&#39;, model_path=&#39;~/Downloads/pos_lebel/0.5_purf.pkl&#39;, n_jobs=1) wo_tree_filtering = pd.read_csv(&#39;~/Downloads/pos_level/0.5_res.csv&#39;, index_col=0) w_tree_filtering = pd.read_csv(&#39;~/Downloads/pos_level/0.5_res_tree_filtering.csv&#39;, index_col=0) merged_df = pd.concat([wo_tree_filtering, w_tree_filtering[&#39;OOB score&#39;]], join=&#39;outer&#39;, axis=1) merged_df.columns = [&#39;antigen_label&#39;, &#39;oob_score_without_tree_filtering&#39;, &#39;oob_score_with_tree_filtering&#39;] merged_df.to_csv(&#39;./data/supplementary_data_4_purf_oob_predictions.csv&#39;) 3.1.1.2 Validation for PURF without tree filtering In Python: for (idx, (antigen, out)) in enumerate(zip(pf3d7_features.index, pf3d7_outcome)): if out == 1: if antigen in REF_ANTIGENS.values(): continue pf3d7_outcome_ = pf3d7_outcome.copy() pf3d7_outcome_[idx] = 0 train_purf(pf3d7_features, pf3d7_outcome_, res_path=&#39;~/Downloads/jackknife/&#39; + antigen + &#39;_res.csv&#39;, pickle_path=&#39;~/Downloads/jackknife/&#39; + antigen + &#39;_purf.pkl&#39;) dir = &#39;~/Downloads/jackknife/&#39; files = os.listdir(dir) for file in files: if file.endswith(&#39;csv&#39;): tmp = pd.read_csv(dir + file, index_col=0)[&#39;antigen_label&#39;] break data_frames = [pd.read_csv(dir + file, index_col=0)[&#39;OOB score&#39;] for file in files if file.endswith(&#39;csv&#39;)] merged_df = pd.concat([tmp] + data_frames, join=&#39;outer&#39;, axis=1) colnames = [&#39;antigen_label&#39;] + [re.match(&#39;PF3D7_[0-9]+\\.[0-9]-p1&#39;, file)[0] for file in files if file.endswith(&#39;csv&#39;)] merged_df.columns = colnames merged_df.to_csv(&#39;./data/supplementary_data_5_validation.csv&#39;) 3.1.1.3 Validation for PURF with tree filtering In Python: for (idx, (antigen, out)) in enumerate(zip(pf3d7_features.index, pf3d7_outcome)): if out == 1: if antigen in REF_ANTIGENS.values(): continue pf3d7_outcome_ = pf3d7_outcome.copy() pf3d7_outcome_[idx] = 0 train_purf(pf3d7_features, pf3d7_outcome_, res_path=&#39;~/Downloads/tree_filtering_jackknife/&#39; + antigen + &#39;_res.csv&#39;, pickle_path=&#39;~/Downloads/tree_filtering_jackknife/&#39; + antigen + &#39;_purf.pkl&#39;, model_path=&#39;~/Downloads/jackknife/&#39; + antigen + &#39;_purf.pkl&#39;, n_jobs=1) dir = &#39;~/Downloads/tree_filtering_jackknife/&#39; files = os.listdir(dir) for file in files: if file.endswith(&#39;csv&#39;): tmp = pd.read_csv(dir + file, index_col=0)[&#39;antigen_label&#39;] break data_frames = [pd.read_csv(dir + file, index_col=0)[&#39;OOB score&#39;] for file in files if file.endswith(&#39;csv&#39;)] merged_df = pd.concat([tmp] + data_frames, join=&#39;outer&#39;, axis=1) colnames = [&#39;antigen_label&#39;] + [re.match(&#39;PF3D7_[0-9]+\\.[0-9]-p1&#39;, file)[0] for file in files if file.endswith(&#39;csv&#39;)] merged_df.columns = colnames merged_df.to_csv(&#39;./data/supplementary_data_6_tree_filtering_validation.csv&#39;) 3.1.2 Plotting In R: library(mixR) library(pracma) library(rlist) library(ggplot2) library(cowplot) library(grid) library(ggbeeswarm) library(ggpubr) data &lt;- read.csv(&quot;./data/supplementary_data_4_purf_oob_predictions.csv&quot;, row.names = 1, check.names = FALSE) # Extract data with only unlabeled proteins data_unl &lt;- data[data$antigen_label == 0, ] validation_wo_tree_filtering &lt;- read.csv(&quot;./data/supplementary_data_5_validation.csv&quot;, row.names = 1, check.names = FALSE) validation_w_tree_filtering &lt;- read.csv(&quot;./data/supplementary_data_6_tree_filtering_validation.csv&quot;, row.names = 1, check.names = FALSE) 3.1.2.1 Plot score distribution fit &lt;- mixfit(data_unl[, &quot;oob_score_with_tree_filtering&quot;], ncomp = 2) # Calculate receiver operating characteristic (ROC) curve # for putative positive and negative samples x &lt;- seq(-0.5, 1.5, by = 0.01) neg_cum &lt;- pnorm(x, mean = fit$mu[1], sd = fit$sd[1]) pos_cum &lt;- pnorm(x, mean = fit$mu[2], sd = fit$sd[2]) fpr &lt;- (1 - neg_cum) / ((1 - neg_cum) + neg_cum) # false positive / (false positive + true negative) tpr &lt;- (1 - pos_cum) / ((1 - pos_cum) + pos_cum) # true positive / (true positive + false negative) p1 &lt;- plot(fit, title = paste0(&quot;PURF with tree filtering&quot;, &quot; (AUROC = &quot;, round(trapz(-fpr, tpr), 2), &quot;)&quot;)) + scale_fill_manual(values = c(&quot;blue&quot;, &quot;red&quot;), labels = c(&quot;Putative negative&quot;, &quot;Putative positive&quot;)) + theme_bw() + theme( panel.grid.major = element_blank(), panel.grid.minor = element_blank(), axis.title = element_text(colour = &quot;black&quot;), axis.text = element_text(colour = &quot;black&quot;), plot.title = element_text(hjust = 0.5, colour = &quot;black&quot;), plot.margin = ggplot2::margin(5, 5, 5, 5, &quot;pt&quot;), legend.title = element_blank(), legend.text = element_text(colour = &quot;black&quot;), legend.position = c(0.8, 0.9), legend.background = element_blank() ) + xlim(-0.3, 1.3) + xlab(&quot;Score (proportion of votes)&quot;) + ylab(&quot;Density&quot;) 3.1.2.2 Percent rank for labeled positives data_ &lt;- data[c(&quot;antigen_label&quot;, &quot;oob_score_with_tree_filtering&quot;)] colnames(data_) &lt;- c(&quot;antigen_label&quot;, &quot;OOB score&quot;) data_$percent_rank &lt;- rank(data_[[&quot;OOB score&quot;]]) / nrow(data) data_ &lt;- data_[data$antigen_label == 1, ] data_ &lt;- data_[order(-data_$percent_rank), ] data_$x &lt;- 1:nrow(data_) / nrow(data_) cat(paste0(&quot;EPR: &quot;, sum(data_$`OOB score` &gt;= 0.5) / nrow(data_), &quot;\\n&quot;)) p2 &lt;- ggplot(data_, aes(x = x, y = `percent_rank`)) + geom_hline(yintercept = 0.5, linetype = &quot;dashed&quot;, color = &quot;black&quot;) + geom_line() + geom_point(aes(color = `OOB score`), size = 1) + scale_colour_gradient2(low = &quot;blue&quot;, mid = &quot;purple&quot;, high = &quot;red&quot;, midpoint = 0.5, limits = c(0, 1)) + theme_bw() + theme( panel.grid.major = element_blank(), panel.grid.minor = element_blank(), axis.title = element_text(colour = &quot;black&quot;), axis.text = element_text(colour = &quot;black&quot;), plot.title = element_text(hjust = 0.5, colour = &quot;black&quot;), plot.margin = ggplot2::margin(5, 5, 5, 5, &quot;pt&quot;), legend.title = element_text(hjust = 0.5, colour = &quot;black&quot;, angle = 0), legend.text = element_text(colour = &quot;black&quot;), legend.position = c(0.35, 0.15), legend.background = element_blank() ) + guides(colour = guide_colourbar(title.position = &quot;top&quot;, direction = &quot;horizontal&quot;)) + ggtitle(paste0(&quot;PURF with tree filtering&quot;, &quot; (AUC = &quot;, round(trapz(c(0, data_$x, 1), c(1, data_$percent_rank, 0)), 2), &quot;)&quot;)) + ylim(0, 1) + xlab(&quot;Ranked known antigens (scaled)&quot;) + ylab(&quot;Percent rank&quot;) + labs(colour = &quot;Score (proportion of votes)&quot;) 3.1.2.3 Comparison of known antigens calculate_known_antigen_scores &lt;- function(validation_data, baseline_scores) { scores &lt;- c() for (i in 2:ncol(validation_data)) { known_antigen &lt;- sort(colnames(validation_data))[i] other_antigens &lt;- sort(colnames(validation_data))[-c(1, i)] scores &lt;- c(scores, mean(validation_data[other_antigens, known_antigen] - baseline_scores[other_antigens, ])) } return(scores) } scores_wo_tree_filtering &lt;- calculate_known_antigen_scores( validation_wo_tree_filtering, data[&quot;oob_score_without_tree_filtering&quot;] ) scores_w_tree_filtering &lt;- calculate_known_antigen_scores( validation_w_tree_filtering, data[&quot;oob_score_with_tree_filtering&quot;] ) data_ &lt;- data.frame( group = factor(c( rep(0, length(scores_wo_tree_filtering)), rep(1, length(scores_w_tree_filtering)) )), score = c(scores_wo_tree_filtering, scores_w_tree_filtering), paired = rep(1:48, 2) ) stats &lt;- compare_means(score ~ group, data = data_, method = &quot;wilcox.test&quot;, paired = TRUE) p3 &lt;- ggplot(data_, aes(x = group, y = score)) + geom_hline(yintercept = 0, color = &quot;black&quot;, linetype = &quot;dashed&quot;) + geom_boxplot(aes(color = group), outlier.color = NA, lwd = 1.5, show.legend = FALSE) + geom_line(aes(group = paired), alpha = 0.6, color = &quot;grey80&quot;) + geom_beeswarm(aes(fill = group), color = &quot;black&quot;, alpha = 0.5, size = 2, cex = 2, priority = &quot;random&quot;, shape = 21 ) + scale_color_manual(values = c(&quot;#f7d59e&quot;, &quot;#fcd7d7&quot;)) + scale_fill_manual(values = c(&quot;#fc9d03&quot;, &quot;red&quot;), labels = c(&quot;Without tree filtering&quot;, &quot;With tree filtering&quot;)) + scale_x_discrete(labels = c(&quot;Without tree filtering&quot;, &quot;With tree filtering&quot;)) + theme_bw() + theme( panel.grid.major = element_blank(), panel.grid.minor = element_blank(), axis.title.x = element_blank(), axis.title.y = element_text(colour = &quot;black&quot;), axis.text = element_text(colour = &quot;black&quot;), plot.title = element_text(hjust = 0.5, colour = &quot;black&quot;), plot.margin = ggplot2::margin(10, 5, 18, 5, &quot;pt&quot;), legend.title = element_blank(), legend.text = element_text(colour = &quot;black&quot;), legend.position = &quot;none&quot; ) + ylab(&quot;Mean difference in scores (proportion of votes)&quot;) 3.1.2.4 Comparison of top 200 candidates calculate_overlapping_candidates &lt;- function(data, validation_data) { top_200 &lt;- list() for (i in 1:48) { data_ &lt;- validation_data[data$antigen_label == 0, ] data_ &lt;- data_[order(-data_[, 1 + i]), ][1:200, ] top_200 &lt;- list.append(top_200, rownames(data_)) } union_top_200 &lt;- unique(unlist(top_200)) cat(paste0(length(union_top_200), &quot;\\n&quot;)) mat &lt;- data.frame(matrix(0, nrow = length(union_top_200), ncol = 48)) rownames(mat) &lt;- union_top_200 colnames(mat) &lt;- 1:48 for (i in 1:48) mat[top_200[[i]], i] &lt;- 1 return(apply(mat, 1, sum)) } agreement_wo_tree_filtering &lt;- calculate_overlapping_candidates(data, validation_wo_tree_filtering) agreement_w_tree_filtering &lt;- calculate_overlapping_candidates(data, validation_w_tree_filtering) y1 &lt;- sapply(1:48, function(x) sum(agreement_wo_tree_filtering &gt;= x)) y2 &lt;- sapply(1:48, function(x) sum(agreement_w_tree_filtering &gt;= x)) data_ &lt;- data.frame( x = rep(1:48, 2), y = c(y1, y2), group = factor(c(rep(0, length(y1)), rep(1, length(y2)))) ) p4 &lt;- ggplot(data_, aes(x = x, y = y, color = group)) + geom_line(alpha = 0.7) + scale_color_manual(values = c(&quot;#fc9d03&quot;, &quot;red&quot;), labels = c(&quot;Without tree filtering&quot;, &quot;With tree filtering&quot;)) + scale_x_reverse(breaks = c(48, 40, 30, 20, 10, 1)) + scale_y_continuous(breaks = c(114, 150, 200, 250)) + theme_bw() + theme( panel.grid.major = element_blank(), panel.grid.minor = element_blank(), axis.title = element_text(colour = &quot;black&quot;), axis.text = element_text(colour = &quot;black&quot;), plot.title = element_text(hjust = 0.5, colour = &quot;black&quot;), plot.margin = ggplot2::margin(10, 5, 5, 5, &quot;pt&quot;), legend.title = element_blank(), legend.text = element_text(colour = &quot;black&quot;), legend.position = c(0.72, 0.15), legend.background = element_blank(), legend.key = element_blank() ) + xlab(&quot;Number of models&quot;) + ylab(&quot;Number of candidate antigens&quot;) Final plot p_combined &lt;- plot_grid(p1, p2, p3, p4, nrow = 1, labels = c(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;)) p_combined 3.2 Model interpretation PURF model interpretation with permutation-based variable importance and Wilcox test. 3.2.1 Analysis 3.2.1.1 Variable importance Permutation-based variable importance and group variable importance. In Python: import pickle import pandas as pd import numpy as np import pickle from sklearn.impute import SimpleImputer from sklearn.preprocessing import MinMaxScaler from scipy.spatial import distance import multiprocessing from joblib import Parallel, delayed num_cores = multiprocessing.cpu_count() from sklearn.ensemble._forest import _generate_unsampled_indices import session_info data = pd.read_csv(&#39;./other_data/pf_ml_input_processed_weighted.csv&#39;, index_col=0) pf3d7_features_processed = data.iloc[:,1:] pf3d7_outcome = np.array(data.antigen_label) purf_model = pickle.load(open(&#39;./pickle_data/0.5_purf_tree_filtering.pkl&#39;, &#39;rb&#39;)) purf = purf_model[&#39;model&#39;] weights = purf_model[&#39;weights&#39;] metadata = pd.read_csv(&#39;./data/supplementary_data_2_pf_protein_variable_metadata.csv&#39;) groups = metadata.loc[np.isin(metadata[&#39;column name&#39;], pf3d7_features_processed.columns), &#39;category&#39;].array def calculate_raw_var_imp_(idx, tree, X, y, weight, groups=None): rng = np.random.RandomState(idx) oob_indices = _generate_unsampled_indices(tree.random_state, y.shape[0], y.shape[0]) oob_pos = np.intersect1d(oob_indices, np.where(y == 1)[0]) noutall = len(oob_pos) pred = tree.predict_proba(X.iloc[oob_pos,:])[:, 1] nrightall = sum(pred == y[oob_pos]) imprt, impsd = [], [] if groups is None: for var in range(X.shape[1]): X_temp = X.copy() X_temp.iloc[:, var] = rng.permutation(X_temp.iloc[:, var]) pred = tree.predict_proba(X_temp.iloc[oob_pos,:])[:, 1] nrightimpall = sum(pred == y[oob_pos]) delta = (nrightall - nrightimpall) / noutall * weight imprt.append(delta) impsd.append(delta * delta) else: for grp in np.unique(groups): X_temp = X.copy() X_temp.iloc[:, groups == grp] = rng.permutation(X_temp.iloc[:, groups == grp]) pred = tree.predict_proba(X_temp.iloc[oob_pos,:])[:, 1] nrightimpall = sum(pred == y[oob_pos]) delta = (nrightall - nrightimpall) / noutall * weight imprt.append(delta) impsd.append(delta * delta) return (imprt, impsd) def calculate_var_imp(model, features, outcome, num_cores, weights=None, groups=None): trees = model.estimators_ idx_list = [i for i in range(len(trees))] if weights is None: weights = np.ones(len(trees)) res = Parallel(n_jobs=num_cores)( delayed(calculate_raw_var_imp_)(idx, trees[idx], features, outcome, weights[idx], groups) for idx in idx_list) imprt, impsd = [], [] for i in range(len(idx_list)): imprt.append(res[i][0]) impsd.append(res[i][1]) imprt = np.array(imprt).sum(axis=0) impsd = np.array(impsd).sum(axis=0) imprt /= sum(weights) impsd = np.sqrt(((impsd / sum(weights)) - imprt * imprt) / sum(weights)) mda = [] for i in range(len(imprt)): if impsd[i] != 0: mda.append(imprt[i] / impsd[i]) else: mda.append(imprt[i]) if groups is None: var_imp = pd.DataFrame({&#39;variable&#39;: features.columns, &#39;meanDecreaseAccuracy&#39;: mda}) else: var_imp = pd.DataFrame({&#39;variable&#39;: np.unique(groups), &#39;meanDecreaseAccuracy&#39;: mda}) return var_imp var_imp = calculate_var_imp(purf, pf3d7_features_processed, pf3d7_outcome, num_cores, weights) grp_var_imp = calculate_var_imp(purf, pf3d7_features_processed, pf3d7_outcome, num_cores, weights, groups) var_imp.to_csv(&#39;./other_data/known_antigen_variable_importance.csv&#39;, index=False) grp_var_imp.to_csv(&#39;./other_data/known_antigen_group_variable_importance.csv&#39;, index=False) 3.2.1.2 Wilcoxon test Variable value comparison between known antigens and other 52 random proteins predicted as negative. In R: library(stringr) library(ggplot2) prediction &lt;- read.csv(&quot;./data/supplementary_data_4_purf_oob_predictions.csv&quot;) known_antigens &lt;- prediction[prediction$antigen_label == 1, ]$protein_id other_proteins &lt;- prediction[prediction$antigen_label == 0 &amp; prediction$oob_score_with_tree_filtering &lt; 0.5, ]$protein_id set.seed(22) random_proteins &lt;- sample(other_proteins, size = 52, replace = FALSE) # Load imputed data data &lt;- read.csv(&quot;./other_data/pf_ml_input_processed_weighted.csv&quot;) data &lt;- data[!duplicated(data), ] compared_group &lt;- sapply(data$X, function(x) if (x %in% known_antigens) 1 else if (x %in% random_proteins) 0 else -1) data &lt;- data[, 3:ncol(data)] # Min-max normalization min_max &lt;- function(x) { (x - min(x)) / (max(x) - min(x)) } data &lt;- data.frame(lapply(data, min_max)) save(compared_group, data, file = &quot;./rdata/known_antigen_wilcox_data.RData&quot;) pval &lt;- c() for (i in 1:ncol(data)) { pval &lt;- c(pval, wilcox.test(data[compared_group == 1, i], data[compared_group == 0, i])$p.value) } adj_pval &lt;- p.adjust(pval, method = &quot;BH&quot;, n = length(pval)) # adj_pval = -log10(adj_pval) wilcox_res &lt;- data.frame(variable = colnames(data), adj_pval = adj_pval) write.csv(wilcox_res, &quot;./other_data/known_antigen_wilcox_res.csv&quot;, row.names = FALSE) 3.2.2 Plotting In R: library(ggplot2) library(reshape2) library(cowplot) library(stringr) colorset &lt;- c(&quot;genomic&quot; = &quot;#0C1C63&quot;, &quot;immunological&quot; = &quot;#408002&quot;, &quot;proteomic&quot; = &quot;#0F80FF&quot;, &quot;structural&quot; = &quot;#FEAE34&quot;) 3.2.2.1 Variable importance var_imp &lt;- read.csv(&quot;./other_data/known_antigen_variable_importance.csv&quot;) var_imp &lt;- var_imp[order(-var_imp$meanDecreaseAccuracy), ] var_imp &lt;- var_imp[1:10, ] metadata &lt;- read.csv(&quot;./data/supplementary_data_2_pf_protein_variable_metadata.csv&quot;, check.names = FALSE) metadata &lt;- metadata[c(&quot;category&quot;, &quot;column name&quot;)] metadata &lt;- metadata[metadata$`column name` %in% var_imp$variable, ] var_imp &lt;- merge(x = var_imp, y = metadata, by.x = &quot;variable&quot;, by.y = &quot;column name&quot;) var_imp$category &lt;- factor(var_imp$category, levels = names(colorset)) var_imp$color &lt;- sapply(var_imp$category, function(x) colorset[x]) var_imp_ &lt;- var_imp firstup &lt;- function(x) { substr(x, 1, 1) &lt;- toupper(substr(x, 1, 1)) x } var_imp_$variable &lt;- sapply(var_imp_$variable, function(x) { x &lt;- str_replace_all(x, &quot;[_\\\\.]&quot;, &quot; &quot;) x &lt;- firstup(x) return(x) }) p1 &lt;- ggplot(var_imp_, aes(x = reorder(variable, meanDecreaseAccuracy), y = meanDecreaseAccuracy, fill = category)) + geom_point(size = 3, pch = 21, color = &quot;black&quot;, alpha = 0.8) + scale_fill_manual(values = colorset, labels = c(&quot;Genomic&quot;, &quot;Immunological&quot;, &quot;Proteomic&quot;, &quot;Structural&quot;)) + coord_flip() + ylim(min(var_imp$meanDecreaseAccuracy), max(var_imp$meanDecreaseAccuracy) + 1) + theme_bw() + theme( panel.grid.major = element_blank(), panel.grid.minor = element_blank(), panel.grid.major.y = element_line(color = &quot;grey80&quot;, size = 0.3, linetype = &quot;dotted&quot;), strip.background = element_blank(), panel.border = element_rect(color = &quot;black&quot;), legend.text = element_text(color = &quot;black&quot;), plot.title = element_text(hjust = 0.5, size = 20), plot.margin = ggplot2::margin(10, 10, 10, 10, &quot;pt&quot;), axis.title.x = element_text(color = &quot;black&quot;), axis.title.y = element_text(color = &quot;black&quot;), axis.text.x = element_text(color = &quot;black&quot;), axis.text.y = element_text(color = &quot;black&quot;), legend.title = element_blank(), legend.position = c(0.7, 0.2), legend.background = element_rect(colour = &quot;black&quot;, size = 0.2) ) + xlab(&quot;&quot;) + ylab(&quot;Mean decrease in accuracy&quot;) 3.2.2.2 Group variable importance grp_var_imp &lt;- read.csv(&quot;./other_data/known_antigen_group_variable_importance.csv&quot;) grp_var_imp_ &lt;- grp_var_imp grp_var_imp_$variable &lt;- sapply(grp_var_imp_$variable, function(x) { x &lt;- str_replace_all(x, &quot;[_\\\\.]&quot;, &quot; &quot;) x &lt;- firstup(x) return(x) }) grp_var_imp_$category &lt;- factor(tolower(grp_var_imp_$variable)) p2 &lt;- ggplot(grp_var_imp_, aes(x = reorder(variable, meanDecreaseAccuracy), y = meanDecreaseAccuracy, fill = category)) + geom_point(size = 3, pch = 21, color = &quot;black&quot;, alpha = 0.8) + scale_fill_manual(values = colorset, labels = c(&quot;Genomic&quot;, &quot;Immunological&quot;, &quot;Proteomic&quot;, &quot;Structural&quot;)) + coord_flip() + ylim(min(grp_var_imp$meanDecreaseAccuracy), max(grp_var_imp$meanDecreaseAccuracy) + 5) + theme_bw() + theme( panel.grid.major = element_blank(), panel.grid.minor = element_blank(), panel.grid.major.y = element_line(color = &quot;grey80&quot;, size = 0.3, linetype = &quot;dotted&quot;), strip.background = element_blank(), panel.border = element_rect(color = &quot;black&quot;), legend.text = element_text(color = &quot;black&quot;, size = 10), plot.title = element_text(hjust = 0.5, size = 20), plot.margin = ggplot2::margin(10, 10, 10, 57, &quot;pt&quot;), axis.title.x = element_text(color = &quot;black&quot;), axis.title.y = element_text(color = &quot;black&quot;), axis.text.x = element_text(color = &quot;black&quot;), axis.text.y = element_text(color = &quot;black&quot;), legend.position = &quot;none&quot; ) + xlab(&quot;&quot;) + ylab(&quot;Mean decrease in accuracy&quot;) 3.2.2.3 Wilcoxon test load(file = &quot;./rdata/known_antigen_wilcox_data.RData&quot;) wilcox_res &lt;- read.csv(&quot;./other_data/known_antigen_wilcox_res.csv&quot;) wilcox_data &lt;- data wilcox_data$compared_group &lt;- compared_group wilcox_data &lt;- wilcox_data[wilcox_data$compared_group != -1, ] wilcox_data &lt;- melt(wilcox_data, id = c(&quot;compared_group&quot;)) wilcox_data &lt;- merge(x = wilcox_data, y = merge(x = var_imp, y = wilcox_res), by = &quot;variable&quot;, all.y = TRUE) wilcox_data$tile_pos &lt;- rep(0, nrow(wilcox_data)) wilcox_data$compared_group &lt;- factor(wilcox_data$compared_group) wilcox_data$variable &lt;- sapply(wilcox_data$variable, function(x) { x &lt;- str_replace_all(x, &quot;[_\\\\.]&quot;, &quot; &quot;) x &lt;- firstup(x) return(x) }) adj_pval_tmp &lt;- c() for (i in 1:nrow(wilcox_data)) { x &lt;- wilcox_data$adj_pval[i] if (x &gt;= 1e-3) { res &lt;- paste0(&quot;italic(p) == &quot;, round(x, 3)) } else { a &lt;- strsplit(format(x, scientific = TRUE, digits = 3), &quot;e&quot;)[[1]] res &lt;- paste0(&quot;italic(p) == &quot;, as.numeric(a[1]), &quot; %*% 10^&quot;, as.integer(a[2])) } adj_pval_tmp &lt;- c(adj_pval_tmp, res) } wilcox_data$adj_pval &lt;- adj_pval_tmp # p3_1 = ggplot(wilcox_data, aes(x=reorder(variable, meanDecreaseAccuracy), y=tile_pos)) + # geom_text(aes(label=adj_pval), size=3, fontface=&#39;plain&#39;, family=&#39;sans&#39;, hjust=0, parse=TRUE) + # scale_fill_gradient(low=&#39;blue&#39;, high=&#39;red&#39;) + # coord_flip() + # theme_bw() + # xlab(&#39;&#39;) + # ylab(&#39;&#39;) + # ylim(0, 0.5) # # legend_1 = get_legend(p3_1 + # theme(legend.title=element_text(vjust=0.7, color=&#39;black&#39;), # legend.background=element_blank()) + # guides(fill=guide_colorbar(title=expression(&quot;-Log&quot;[10]*&quot;FDR&quot;), # direction = &quot;horizontal&quot;))) p3 &lt;- ggplot(wilcox_data, aes(x = reorder(variable, meanDecreaseAccuracy), y = value, fill = compared_group)) + geom_boxplot(outlier.color = NA, alpha = 0.3, lwd = 0.3) + geom_point( color = &quot;black&quot;, shape = 21, stroke = 0.3, alpha = 0.5, size = 0.5, position = position_jitterdodge() ) + geom_text(aes(label = adj_pval), y = 1.1, size = 3, fontface = &quot;plain&quot;, family = &quot;sans&quot;, hjust = 0, parse = TRUE) + geom_vline(xintercept = 1:9 + 0.5, color = &quot;grey80&quot;, linetype = &quot;solid&quot;, size = 0.1) + coord_flip(ylim = c(0, 1), clip = &quot;off&quot;) + scale_fill_manual( breaks = c(&quot;1&quot;, &quot;0&quot;), values = c(&quot;red&quot;, &quot;blue&quot;), labels = c(&quot;Known antigens&quot;, &quot;Random predicted non-antigens&quot;) ) + theme_bw() + xlab(&quot;&quot;) + ylab(&quot;Normalized variable value&quot;) legend_2 &lt;- get_legend(p3 + theme( legend.title = element_blank(), legend.background = element_blank(), legend.key = element_blank(), legend.direction = &quot;horizontal&quot;, legend.position = c(0.35, 0.9) )) p3 &lt;- p3 + theme( panel.grid.major = element_blank(), panel.grid.minor = element_blank(), strip.background = element_blank(), panel.border = element_rect(size = 0.2, colour = &quot;black&quot;), plot.title = element_text(hjust = 0.5), plot.margin = ggplot2::margin(10, 90, 10, 0, &quot;pt&quot;), legend.text = element_text(colour = &quot;black&quot;), axis.title.x = element_text(color = &quot;black&quot;), axis.title.y = element_text(color = &quot;black&quot;), axis.text.x = element_text(color = &quot;black&quot;), axis.text.y = element_text(color = &quot;black&quot;), legend.position = &quot;none&quot; ) Final plot p_combined &lt;- plot_grid( plot_grid(p1, p3, labels = c(&quot;a&quot;, &quot;b&quot;), rel_widths = c(0.47, 0.53) ), plot_grid(p2, NULL, legend_2, labels = c(&quot;c&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;), nrow = 1, rel_widths = c(0.47, 0.13, 0.4) ), ncol = 1, rel_heights = c(0.65, 0.35) ) p_combined sessionInfo() ## R version 4.2.3 (2023-03-15) ## Platform: x86_64-apple-darwin17.0 (64-bit) ## Running under: macOS Big Sur ... 10.16 ## ## Matrix products: default ## BLAS: /Library/Frameworks/R.framework/Versions/4.2/Resources/lib/libRblas.0.dylib ## LAPACK: /Library/Frameworks/R.framework/Versions/4.2/Resources/lib/libRlapack.dylib ## ## locale: ## [1] en_US.UTF-8/en_US.UTF-8/en_US.UTF-8/C/en_US.UTF-8/en_US.UTF-8 ## ## attached base packages: ## [1] grid stats graphics grDevices utils datasets methods ## [8] base ## ## other attached packages: ## [1] stringr_1.4.1 ggpubr_0.4.0 ggbeeswarm_0.6.0 cowplot_1.1.1 ## [5] ggplot2_3.4.2 rlist_0.4.6.2 pracma_2.3.8 mixR_0.2.0 ## ## loaded via a namespace (and not attached): ## [1] Rcpp_1.0.9 lattice_0.20-45 tidyr_1.2.0 png_0.1-7 ## [5] assertthat_0.2.1 digest_0.6.29 utf8_1.2.2 R6_2.5.1 ## [9] backports_1.4.1 evaluate_0.16 highr_0.9 pillar_1.8.1 ## [13] rlang_1.1.0 rstudioapi_0.14 data.table_1.14.2 car_3.1-0 ## [17] jquerylib_0.1.4 R.utils_2.12.0 R.oo_1.25.0 Matrix_1.5-3 ## [21] reticulate_1.25 rmarkdown_2.16 styler_1.8.0 munsell_0.5.0 ## [25] broom_1.0.0 compiler_4.2.3 vipor_0.4.5 xfun_0.32 ## [29] pkgconfig_2.0.3 htmltools_0.5.3 tidyselect_1.1.2 tibble_3.1.8 ## [33] bookdown_0.28 codetools_0.2-19 fansi_1.0.3 dplyr_1.0.9 ## [37] withr_2.5.0 R.methodsS3_1.8.2 jsonlite_1.8.0 gtable_0.3.0 ## [41] lifecycle_1.0.3 DBI_1.1.3 magrittr_2.0.3 scales_1.2.1 ## [45] carData_3.0-5 cli_3.6.1 stringi_1.7.8 cachem_1.0.6 ## [49] ggsignif_0.6.3 bslib_0.4.0 generics_0.1.3 vctrs_0.6.2 ## [53] tools_4.2.3 R.cache_0.16.0 glue_1.6.2 beeswarm_0.4.0 ## [57] purrr_0.3.4 abind_1.4-5 fastmap_1.1.0 yaml_2.3.5 ## [61] colorspace_2.0-3 rstatix_0.7.0 knitr_1.40 sass_0.4.2 "],["id_04_candidate_antigen_clustering.html", "Section 4 Candidate antigen clustering 4.1 Clustering analysis of the proximity matrix from the tree-filtered PURF model 4.2 Comparison of the candidate clustering groups 4.3 Important variables for candidate clustering groups 4.4 Comparison of important variables", " Section 4 Candidate antigen clustering 4.1 Clustering analysis of the proximity matrix from the tree-filtered PURF model 4.1.1 Analysis In Python: import pandas as pd import numpy as np import pickle from purf.pu_ensemble import PURandomForestClassifier from sklearn.ensemble._forest import _generate_unsampled_indices import multiprocessing from joblib import Parallel, delayed num_cores = multiprocessing.cpu_count() import session_info # input set (5393, 1 + 272) data = pd.read_csv(&#39;./data/supplementary_data_3_pf_ml_input.csv&#39;, index_col=0) features = data.iloc[:, 1:] outcome = np.array(data.antigen_label) # Imputation imputer = SimpleImputer(strategy=&#39;median&#39;) X = imputer.fit_transform(features) # Load model model_tree_filtered = pickle.load(open(&#39;./pickle_data/0.5_purf_tree_filtering.pkl&#39;, &#39;rb&#39;)) model = model_tree_filtered[&#39;model&#39;] weights = model_tree_filtered[&#39;weights&#39;] def calculate_proximity_(trees, y, leaf_indices): same_leaf_mat = np.zeros([y.shape[0], y.shape[0]]) same_oob_mat = np.zeros([y.shape[0], y.shape[0]]) for idx, tree in enumerate(trees): oob_indices = _generate_unsampled_indices(tree.random_state, y.shape[0], y.shape[0]) for i in oob_indices: for j in oob_indices: same_oob_mat[i, j] += 1 if leaf_indices[i, idx] == leaf_indices[j, idx]: same_leaf_mat[i, j] += 1 return (same_leaf_mat, same_oob_mat) # ------------------------------------------ # Calculate proximity without tree filtering # ------------------------------------------ trees = model.estimators_ leaf_indices = model.apply(X) idx_list = [i for i in range(len(trees))] idx_list = np.array_split(idx_list, 1000) res_1 = Parallel(n_jobs=num_cores)( delayed(calculate_proximity_)(list(trees[i] for i in idx), outcome, leaf_indices[:, idx]) for idx in idx_list[0:round(len(idx_list) / 2)]) print(&#39;Done first part!&#39;) res_2 = Parallel(n_jobs=num_cores)( delayed(calculate_proximity_)(list(trees[i] for i in idx), outcome, leaf_indices[:, idx]) for idx in idx_list[round(len(idx_list) / 2):]) print(&#39;Done second part!&#39;) same_leaf_mat = sum([r[0] for r in res_1 + res_2]) same_oob_mat = sum([r[1] for r in res_1 + res_2]) prox_mat = pd.DataFrame(np.divide(same_leaf_mat, same_oob_mat, out=np.zeros_like(same_leaf_mat), where=same_oob_mat!=0)) prox_mat.index = features.index prox_mat.columns = features.index prox_mat.to_csv(&#39;./other_data/proximity_values.csv&#39;, index=False) # ------------------------------------------ # Calculate proximity with tree filtering # ------------------------------------------ trees = model.estimators_ leaf_indices = model.apply(X) idx_list = [i for i in range(len(trees)) if weights[i] == 1] idx_list = np.array_split(idx_list, 1000) res = Parallel(n_jobs=num_cores)( delayed(calculate_proximity_)(list(trees[i] for i in idx), outcome, leaf_indices[:, idx]) for idx in idx_list) same_leaf_mat = sum([r[0] for r in res]) same_oob_mat = sum([r[1] for r in res]) prox_mat = pd.DataFrame(np.divide(same_leaf_mat, same_oob_mat, out=np.zeros_like(same_leaf_mat), where=same_oob_mat!=0)) prox_mat.index = features.index prox_mat.columns = features.index prox_mat.to_csv(&#39;./other_data/proximity_values_tree_filtering.csv&#39;, index=False) 4.1.1.1 Multi-dimensional scaling In R: # Multidimensional scaling prox_mat &lt;- read.csv(&quot;./other_data/proximity_values_tree_filtering.csv&quot;, check.names = FALSE) mds &lt;- cmdscale(as.dist(1 - prox_mat), k = ncol(prox_mat) - 1, eig = TRUE) var_explained &lt;- round(mds$eig * 100 / sum(mds$eig), 2) print(paste0(&quot;Dimension 1 (&quot;, var_explained[1], &quot;%)&quot;)) print(paste0(&quot;Dimension 2 (&quot;, var_explained[2], &quot;%)&quot;)) print(paste0(&quot;Dimension 3 (&quot;, var_explained[3], &quot;%)&quot;)) mds &lt;- as.data.frame(mds$points) write.csv(mds, &quot;./other_data/mds_proximity_values_tree_filtering.csv&quot;) 4.1.2 Plotting In R: library(factoextra) library(NbClust) library(ggplot2) library(stringr) library(ggrepel) library(cowplot) library(reshape2) library(rlist) library(ggpubr) library(ggbeeswarm) library(ggforce) library(cluster) library(umap) prediction &lt;- read.csv(&quot;./data/supplementary_data_4_purf_oob_predictions.csv&quot;) prediction &lt;- prediction[order(-prediction$oob_score_with_tree_filtering), ] top_200 &lt;- prediction[prediction$antigen_label == 0, ]$protein_id[1:200] mds &lt;- read.csv(&quot;./other_data/mds_proximity_values_tree_filtering.csv&quot;, row.names = 1, check.names = FALSE) mds_ &lt;- mds[rownames(mds) %in% top_200, ] 4.1.2.1 Clustering on candidate antigens # Gap statistic set.seed(123) gap_stat &lt;- clusGap(mds_, kmeans, nstart = 100, K.max = 10, B = 100, iter.max = 50) p0_1 &lt;- fviz_gap_stat(gap_stat, maxSE = list(method = &quot;Tibs2001SEmax&quot;, SE.factor = 2)) + labs(title = &quot;Gap statistic method&quot;) # Silhouette method set.seed(123) p0_2 &lt;- fviz_nbclust(mds_, kmeans, nstart = 100, method = &quot;silhouette&quot;) + labs(title = &quot;Silhouette method&quot;) # Elbow method set.seed(123) p0_3 &lt;- fviz_nbclust(mds_, kmeans, nstart = 100, method = &quot;wss&quot;) + geom_vline(xintercept = 3, linetype = 2, color = &quot;steelblue&quot;) + labs(title = &quot;Elbow method&quot;) label &lt;- read.csv(&quot;./other_data/pf_antigen_labels.csv&quot;, row.names = 1, check.names = FALSE) label$antigen_label[rownames(label) %in% c(&quot;PF3D7_0304600.1-p1&quot;, &quot;PF3D7_0424100.1-p1&quot;, &quot;PF3D7_0206900.1-p1&quot;, &quot;PF3D7_0209000.1-p1&quot;)] &lt;- 2 # Clustering set.seed(123) clusters &lt;- kmeans(mds_, 3, nstart = 100)$cluster label$antigen_label[rownames(label) %in% names(clusters)[clusters == 1]] &lt;- -1 label$antigen_label[rownames(label) %in% names(clusters)[clusters == 2]] &lt;- -2 label$antigen_label[rownames(label) %in% names(clusters)[clusters == 3]] &lt;- -3 protein_id_1 &lt;- rownames(label)[label$antigen_label == -1] protein_id_2 &lt;- rownames(label)[label$antigen_label == -2] protein_id_3 &lt;- rownames(label)[label$antigen_label == -3] save(protein_id_1, protein_id_2, protein_id_3, file = &quot;./rdata/clustering_groups.RData&quot;) # Save candidate gene accessions for GO enrichment analysis gene_accession_1 &lt;- str_replace_all(protein_id_1, &quot;\\\\.[1-9]-p1&quot;, &quot;&quot;) gene_accession_2 &lt;- str_replace_all(protein_id_2, &quot;\\\\.[1-9]-p1&quot;, &quot;&quot;) gene_accession_3 &lt;- str_replace_all(protein_id_3, &quot;\\\\.[1-9]-p1&quot;, &quot;&quot;) write.table(data.frame(&quot;acc&quot; = gene_accession_1), sep = &quot;, &quot;, row.names = FALSE, col.names = FALSE, file = &quot;./other_data/top_200_candidates_gene_accession_1.csv&quot; ) write.table(data.frame(&quot;acc&quot; = gene_accession_2), sep = &quot;, &quot;, row.names = FALSE, col.names = FALSE, file = &quot;./other_data/top_200_candidates_gene_accession_2.csv&quot; ) write.table(data.frame(&quot;acc&quot; = gene_accession_3), sep = &quot;, &quot;, row.names = FALSE, col.names = FALSE, file = &quot;./other_data/top_200_candidates_gene_accession_3.csv&quot; ) set.seed(22) umap_res &lt;- umap(mds) umap_df &lt;- as.data.frame(umap_res$layout) rownames(umap_df) &lt;- rownames(mds) umap_df$label &lt;- label$antigen_label umap_df_subset &lt;- umap_df[umap_df$label %in% c(1, 2, -1, -2, -3), ] umap_df_subset$label &lt;- factor(umap_df_subset$label) umap_df_subset &lt;- umap_df_subset[order(umap_df_subset$label), ] umap_df_subset$label_text &lt;- &quot;&quot; umap_df_subset$label_text[rownames(umap_df_subset) == &quot;PF3D7_0304600.1-p1&quot;] &lt;- &quot;CSP&quot; umap_df_subset$label_text[rownames(umap_df_subset) == &quot;PF3D7_0424100.1-p1&quot;] &lt;- &quot;RH5&quot; umap_df_subset$label_text[rownames(umap_df_subset) == &quot;PF3D7_0206900.1-p1&quot;] &lt;- &quot;MSP5&quot; umap_df_subset$label_text[rownames(umap_df_subset) == &quot;PF3D7_0209000.1-p1&quot;] &lt;- &quot;P230&quot; p1_1 &lt;- ggplot(data = umap_df_subset, aes(x = `V1`, y = `V2`)) + geom_point(aes(fill = label), shape = 21, alpha = 0.7, color = &quot;grey30&quot;) + # geom_mark_ellipse(aes(fill=label, filter=!label %in% c(1,2)), size=0, alpha=0.2, expand=unit(1, &quot;mm&quot;), color=&#39;grey90&#39;) + scale_fill_manual(breaks = c(-1, -2, -3, 1, 2), values = c(&quot;#03a1fc&quot;, &quot;#984EA3&quot;, &quot;#FF7F00&quot;, &quot;#b8ffe0&quot;, &quot;#ffee00&quot;), labels = c(&quot;Candidate antigen (Group 1)&quot;, &quot;Candidate antigen (Group 2)&quot;, &quot;Candidate antigen (Group 3)&quot;, &quot;Known antigen&quot;, &quot;Reference antigen&quot;)) + geom_text_repel(aes(label = label_text), size = 3.5, nudge_x = -0.5, nudge_y = 1, point.padding = 0.1) + theme_bw() + theme( panel.grid.major = element_blank(), panel.grid.minor = element_blank(), plot.margin = ggplot2::margin(5, 0, 0, 5, &quot;pt&quot;), axis.title = element_text(colour = &quot;black&quot;), axis.text.x = element_text(colour = &quot;black&quot;), axis.text.y = element_text(colour = &quot;black&quot;), plot.title = element_text(hjust = 0.5, colour = &quot;black&quot;), legend.title = element_blank(), legend.background = element_blank(), legend.key = element_blank() ) + xlim(min(umap_df_subset$`V1`), max(umap_df_subset$`V1`)) + ylim(min(umap_df_subset$`V2`), max(umap_df_subset$`V2`)) + xlab(&quot;Dimension 1&quot;) + ylab(&quot;Dimension 2&quot;) 4.1.2.2 Difference in scores Prediction scores of clustering groups before and after tree filtering. prediction &lt;- read.csv(&quot;./data/supplementary_data_4_purf_oob_predictions.csv&quot;, row.names = 1, check.names = FALSE)[, 2:3] load(file = &quot;./rdata/clustering_groups.RData&quot;) data_subset &lt;- prediction[rownames(prediction) %in% c(protein_id_1, protein_id_2, protein_id_3), ] data_subset$label &lt;- 0 data_subset$label[rownames(data_subset) %in% protein_id_1] &lt;- &quot;Group 1&quot; data_subset$label[rownames(data_subset) %in% protein_id_2] &lt;- &quot;Group 2&quot; data_subset$label[rownames(data_subset) %in% protein_id_3] &lt;- &quot;Group 3&quot; data_subset$label &lt;- factor(data_subset$label) pval &lt;- c() ds &lt;- list() for (i in 1:3) { ds_ &lt;- melt(data_subset[data_subset$label == paste0(&quot;Group &quot;, i), ]) ds_$paired &lt;- rep(1:(nrow(ds_) / 2), 2) pval &lt;- c(pval, compare_means(value ~ variable, data = ds_, method = &quot;wilcox.test&quot;, paired = TRUE)$p) ds &lt;- list.append(ds, ds_) } adj_pval &lt;- p.adjust(pval, method = &quot;BH&quot;, n = length(pval)) p2_1 &lt;- ggplot(data = ds[[1]], aes(x = variable, y = value)) + geom_boxplot(aes(color = variable), outlier.color = NA, lwd = 1.5, show.legend = TRUE) + geom_line(aes(group = paired), alpha = 0.6, color = &quot;grey80&quot;) + geom_beeswarm(aes(fill = variable), color = &quot;black&quot;, alpha = 0.5, size = 2, cex = 2.5, priority = &quot;random&quot;, shape = 21 ) + # annotate(&quot;segment&quot;, x=1, xend=2, y=0.991, yend=0.991, colour=&quot;black&quot;) + # annotate(&quot;segment&quot;, x=1, xend=1, y=0.991, yend=0.989, colour=&quot;black&quot;) + # annotate(&quot;segment&quot;, x=2, xend=2, y=0.991, yend=0.989, colour=&quot;black&quot;) + annotate(&quot;text&quot;, x = 1.5, y = 0.994, label = paste0(&quot;p = &quot;, round(adj_pval[1], 3))) + scale_color_manual( breaks = c( &quot;oob_score_without_tree_filtering&quot;, &quot;oob_score_with_tree_filtering&quot; ), values = c(&quot;#f7d59e&quot;, &quot;#fcd7d7&quot;), labels = c(&quot;Without tree filtering&quot;, &quot;With tree filtering&quot;) ) + scale_fill_manual( breaks = c( &quot;oob_score_without_tree_filtering&quot;, &quot;oob_score_with_tree_filtering&quot; ), values = c(&quot;#fc9d03&quot;, &quot;red&quot;), labels = c(&quot;Without tree filtering&quot;, &quot;With tree filtering&quot;) ) + scale_x_discrete( breaks = c( &quot;oob_score_without_tree_filtering&quot;, &quot;oob_score_with_tree_filtering&quot; ), labels = c(&quot;Without tree filtering&quot;, &quot;With tree filtering&quot;) ) + theme_bw() + theme( panel.grid.major = element_blank(), panel.grid.minor = element_blank(), plot.margin = ggplot2::margin(5, 0, 5, 5, &quot;pt&quot;), axis.title = element_text(colour = &quot;black&quot;), plot.title = element_text(hjust = 0.5, colour = &quot;black&quot;), axis.text.x = element_text(angle = 30, colour = &quot;black&quot;, hjust = 1, vjust = 1), axis.text.y = element_text(colour = &quot;black&quot;), legend.position = &quot;none&quot; ) + xlab(&quot;&quot;) + ylab(&quot;Score (proportion of votes)&quot;) + ylim(0.935, 1) + ggtitle(&quot;Group 1&quot;) p2_2 &lt;- ggplot(data = ds[[2]], aes(x = variable, y = value)) + geom_boxplot(aes(color = variable), outlier.color = NA, lwd = 1.5, show.legend = TRUE) + geom_line(aes(group = paired), alpha = 0.6, color = &quot;grey80&quot;) + geom_beeswarm(aes(fill = variable), color = &quot;black&quot;, alpha = 0.5, size = 2, cex = 2.5, priority = &quot;random&quot;, shape = 21 ) + # annotate(&quot;segment&quot;, x=1, xend=2, y=0.997, yend=0.997, colour=&quot;black&quot;) + # annotate(&quot;segment&quot;, x=1, xend=1, y=0.997, yend=0.995, colour=&quot;black&quot;) + # annotate(&quot;segment&quot;, x=2, xend=2, y=0.997, yend=0.995, colour=&quot;black&quot;) + annotate(&quot;text&quot;, x = 1.5, y = 1, label = paste0(&quot;p = &quot;, round(adj_pval[2], 3))) + scale_color_manual( breaks = c( &quot;oob_score_without_tree_filtering&quot;, &quot;oob_score_with_tree_filtering&quot; ), values = c(&quot;#f7d59e&quot;, &quot;#fcd7d7&quot;), labels = c(&quot;Without tree filtering&quot;, &quot;With tree filtering&quot;) ) + scale_fill_manual( breaks = c( &quot;oob_score_without_tree_filtering&quot;, &quot;oob_score_with_tree_filtering&quot; ), values = c(&quot;#fc9d03&quot;, &quot;red&quot;), labels = c(&quot;Without tree filtering&quot;, &quot;With tree filtering&quot;) ) + scale_x_discrete( breaks = c( &quot;oob_score_without_tree_filtering&quot;, &quot;oob_score_with_tree_filtering&quot; ), labels = c(&quot;Without tree filtering&quot;, &quot;With tree filtering&quot;) ) + theme_bw() + theme( panel.grid.major = element_blank(), panel.grid.minor = element_blank(), plot.margin = ggplot2::margin(5, 0, 5, 0, &quot;pt&quot;), axis.title = element_text(colour = &quot;black&quot;), axis.text.x = element_text(angle = 30, colour = &quot;black&quot;, hjust = 1, vjust = 1), axis.text.y = element_blank(), axis.ticks.y = element_blank(), plot.title = element_text(hjust = 0.5, colour = &quot;black&quot;), legend.position = &quot;none&quot; ) + xlab(&quot;&quot;) + ylab(&quot;&quot;) + ylim(0.935, 1) + ggtitle(&quot;Group 2&quot;) p2_3 &lt;- ggplot(data = ds[[3]], aes(x = variable, y = value)) + geom_boxplot(aes(color = variable), outlier.color = NA, lwd = 1.5, show.legend = TRUE) + geom_line(aes(group = paired), alpha = 0.6, color = &quot;grey80&quot;) + geom_beeswarm(aes(fill = variable), color = &quot;black&quot;, alpha = 0.5, size = 2, cex = 2.5, priority = &quot;random&quot;, shape = 21 ) + # annotate(&quot;segment&quot;, x=1, xend=2, y=0.997, yend=0.997, colour=&quot;black&quot;) + # annotate(&quot;segment&quot;, x=1, xend=1, y=0.997, yend=0.995, colour=&quot;black&quot;) + # annotate(&quot;segment&quot;, x=2, xend=2, y=0.997, yend=0.995, colour=&quot;black&quot;) + annotate(&quot;text&quot;, x = 1.5, y = 1, label = paste0(&quot;p = &quot;, round(adj_pval[3], 3))) + scale_color_manual( breaks = c( &quot;oob_score_without_tree_filtering&quot;, &quot;oob_score_with_tree_filtering&quot; ), values = c(&quot;#f7d59e&quot;, &quot;#fcd7d7&quot;), labels = c(&quot;Without tree filtering&quot;, &quot;With tree filtering&quot;) ) + scale_fill_manual( breaks = c( &quot;oob_score_without_tree_filtering&quot;, &quot;oob_score_with_tree_filtering&quot; ), values = c(&quot;#fc9d03&quot;, &quot;red&quot;), labels = c(&quot;Without tree filtering&quot;, &quot;With tree filtering&quot;) ) + scale_x_discrete( breaks = c( &quot;oob_score_without_tree_filtering&quot;, &quot;oob_score_with_tree_filtering&quot; ), labels = c(&quot;Without tree filtering&quot;, &quot;With tree filtering&quot;) ) + theme_bw() + theme( panel.grid.major = element_blank(), panel.grid.minor = element_blank(), plot.margin = ggplot2::margin(5, 5, 5, 0, &quot;pt&quot;), axis.title = element_text(colour = &quot;black&quot;), axis.text.x = element_text(angle = 30, colour = &quot;black&quot;, hjust = 1, vjust = 1), axis.text.y = element_blank(), axis.ticks.y = element_blank(), plot.title = element_text(hjust = 0.5, colour = &quot;black&quot;), legend.position = &quot;none&quot; ) + xlab(&quot;&quot;) + ylab(&quot;&quot;) + ylim(0.935, 1) + ggtitle(&quot;Group 3&quot;) Final plot # p_1 = plot_grid(p1_1, legend_1, p1_2, p1_3, nrow=2, rel_widths=c(0.5, 0.5)) p_2 &lt;- plot_grid(p2_1, p2_2, p2_3, NULL, nrow = 1, rel_widths = c(0.28, 0.25, 0.25, 0.03)) png(file = &quot;./figures/Fig 4.png&quot;, width = 3500, height = 2200, res = 600) print(p1_1) dev.off() pdf(file = &quot;../figures/Fig 4.pdf&quot;, width = 7, height = 4.4) print(p1_1) dev.off() png(file = &quot;./figures/Supplementary Fig 8.png&quot;, width = 6000, height = 4000, res = 600) print(p_2) dev.off() pdf(file = &quot;../supplementary_figures/Supplementary Fig 8.pdf&quot;, width = 12, height = 8) print(p_2) dev.off() 4.2 Comparison of the candidate clustering groups Comparisons of clustering groups before and after tree filtering in terms of distances to reference antigens and predictions scores. 4.2.1 Plotting In R: library(ggplot2) library(ggbeeswarm) library(cowplot) library(ggpubr) library(rlist) prox_wo_tree_filtering &lt;- read.csv(&quot;./other_data/proximity_values.csv&quot;, check.names = FALSE) prox_w_tree_filtering &lt;- read.csv(&quot;./other_data/proximity_values_tree_filtering.csv&quot;, check.names = FALSE) rownames(prox_wo_tree_filtering) &lt;- colnames(prox_wo_tree_filtering) rownames(prox_w_tree_filtering) &lt;- colnames(prox_w_tree_filtering) dist_wo_tree_filtering &lt;- 1 - prox_wo_tree_filtering dist_w_tree_filtering &lt;- 1 - prox_w_tree_filtering diff_dist &lt;- dist_w_tree_filtering - dist_wo_tree_filtering load(file = &quot;./rdata/clustering_groups.RData&quot;) # CSP, RH5, MSP5, P230 ref &lt;- c(&quot;PF3D7_0304600.1-p1&quot;, &quot;PF3D7_0424100.1-p1&quot;, &quot;PF3D7_0206900.1-p1&quot;, &quot;PF3D7_0209000.1-p1&quot;) dist_wo_tree_filtering[ref, ref] dist_w_tree_filtering[ref, ref] diff_dist[ref, ref] plot_boxplots &lt;- function(protein_id, protein_name, ylim1, ylim2) { dist_0 &lt;- dist_wo_tree_filtering[c(protein_id_1, protein_id_2, protein_id_3), protein_id] dist_1 &lt;- dist_w_tree_filtering[c(protein_id_1, protein_id_2, protein_id_3), protein_id] dist_smry &lt;- data.frame( label = rep(c( rep(&quot;Group 1&quot;, length(protein_id_1)), rep(&quot;Group 2&quot;, length(protein_id_2)), rep(&quot;Group 3&quot;, length(protein_id_3)) )), value = c(dist_0, dist_1), variable = factor(c(rep(0, length(dist_0)), rep(1, length(dist_1)))) ) pval &lt;- c() ds &lt;- list() for (i in 1:3) { ds_ &lt;- dist_smry[dist_smry$label == paste0(&quot;Group &quot;, i), ] ds_$paired &lt;- rep(1:(nrow(ds_) / 2), 2) pval &lt;- c(pval, compare_means(value ~ variable, data = ds_, method = &quot;wilcox.test&quot;, paired = TRUE )$p) ds &lt;- list.append(ds, ds_) } adj_pval &lt;- p.adjust(pval, method = &quot;BH&quot;, n = length(pval)) plots &lt;- list() for (i in 1:3) { p &lt;- ggplot(data = ds[[i]], aes(x = variable, y = value)) + geom_hline(yintercept = 0.5, linetype = &quot;dashed&quot;, color = &quot;grey60&quot;) + geom_boxplot(aes(color = variable), outlier.color = NA, lwd = 1.5, show.legend = FALSE, fill = &quot;transparent&quot;) + geom_line(aes(group = paired), alpha = 0.6, color = &quot;grey80&quot;) + geom_beeswarm(aes(fill = variable), color = &quot;black&quot;, alpha = 0.5, size = 2, cex = 2, priority = &quot;random&quot;, shape = 21 ) + # annotate(&quot;segment&quot;, x=1, xend=2, y=max(ds[[i]]$value) + 0.04, yend=max(ds[[i]]$value) + 0.04, # colour=&quot;black&quot;) + # annotate(&quot;segment&quot;, x=1, xend=1, y=max(ds[[i]]$value) + 0.04, yend=max(ds[[i]]$value) + 0.03, # colour=&quot;black&quot;) + # annotate(&quot;segment&quot;, x=2, xend=2, y=max(ds[[i]]$value) + 0.04, yend=max(ds[[i]]$value) + 0.03, # colour=&quot;black&quot;) + { if (adj_pval[i] &gt;= 1e-3) { annotate(&quot;text&quot;, x = 1.5, y = max(ds[[i]]$value) + 0.06, label = paste0(&quot;p = &quot;, round(adj_pval[i], 3)) ) } else { annotate(&quot;text&quot;, x = 1.5, y = max(ds[[i]]$value) + 0.06, label = paste0(&quot;p = &quot;, formatC(adj_pval[i], format = &quot;e&quot;, digits = 2)) ) } } + scale_color_manual(values = c(&quot;#f7d59e&quot;, &quot;#fcd7d7&quot;)) + scale_fill_manual( values = c(&quot;#fc9d03&quot;, &quot;red&quot;), labels = c(&quot;Without tree filtering&quot;, &quot;With tree filtering&quot;) ) + scale_x_discrete(labels = c(&quot;Without tree filtering&quot;, &quot;With tree filtering&quot;)) + theme_bw() + { if (i == 1) { theme( panel.grid.major = element_blank(), panel.grid.minor = element_blank(), plot.margin = ggplot2::margin(5, 0, 5, 25, &quot;pt&quot;), axis.title = element_text(colour = &quot;black&quot;), plot.title = element_text(hjust = 0.5, colour = &quot;black&quot;, size = 8), axis.text.x = element_text(colour = &quot;black&quot;, angle = 45, vjust = 1, hjust = 1), axis.text.y = element_text(colour = &quot;black&quot;), rect = element_rect(fill = &quot;transparent&quot;), legend.position = &quot;none&quot; ) } else if (i == 2) { theme( panel.grid.major = element_blank(), panel.grid.minor = element_blank(), plot.margin = ggplot2::margin(5, 0, 5, -5, &quot;pt&quot;), axis.title = element_text(colour = &quot;black&quot;), plot.title = element_text(hjust = 0.5, colour = &quot;black&quot;, size = 8), axis.text.x = element_text(colour = &quot;black&quot;, angle = 45, vjust = 1, hjust = 1), axis.text.y = element_blank(), axis.ticks.y = element_blank(), rect = element_rect(fill = &quot;transparent&quot;), legend.position = &quot;none&quot; ) } else { theme( panel.grid.major = element_blank(), panel.grid.minor = element_blank(), plot.margin = ggplot2::margin(5, 5, 5, -5, &quot;pt&quot;), axis.title = element_text(colour = &quot;black&quot;), plot.title = element_text(hjust = 0.5, colour = &quot;black&quot;, size = 8), axis.text.x = element_text(colour = &quot;black&quot;, angle = 45, vjust = 1, hjust = 1), axis.text.y = element_blank(), axis.ticks.y = element_blank(), rect = element_rect(fill = &quot;transparent&quot;), legend.position = &quot;none&quot; ) } } + xlab(&quot;&quot;) + { if (i == 1) { ylab(paste0(&quot;Euclidean distance to &quot;, protein_name)) } else { ylab(&quot;&quot;) } } + ylim(ylim1) + ggtitle(paste0(&quot;Group &quot;, i)) plots &lt;- list.append(plots, p) } # Plot difference diff_grps &lt;- diff_dist[c(protein_id_1, protein_id_2, protein_id_3), protein_id] ds &lt;- data.frame( value = c(diff_grps), group = factor(c( rep(&quot;Group 1&quot;, length(protein_id_1)), rep(&quot;Group 2&quot;, length(protein_id_2)), rep(&quot;Group 3&quot;, length(protein_id_3)) )) ) stats &lt;- compare_means(value ~ group, data = ds, method = &quot;wilcox.test&quot;, p.adjust.method = &quot;BH&quot;) p &lt;- ggplot(data = ds, aes(x = group, y = value, fill = group)) + geom_hline(yintercept = 0, linetype = &quot;dashed&quot;, color = &quot;grey80&quot;) + geom_boxplot(outlier.colour = NA, alpha = 0.3, lwd = 0.3) + geom_beeswarm(aes(fill = group), color = &quot;black&quot;, alpha = 0.5, size = 1.5, cex = 1.5, priority = &quot;random&quot;, shape = 21 ) + annotate(&quot;segment&quot;, x = 1, xend = 1.95, y = max(ds$value) + 0.004, yend = max(ds$value) + 0.004, colour = &quot;black&quot;) + annotate(&quot;segment&quot;, x = 1, xend = 1, y = max(ds$value) + 0.002, yend = max(ds$value) + 0.004, colour = &quot;black&quot;) + annotate(&quot;segment&quot;, x = 1.95, xend = 1.95, y = max(ds$value) + 0.002, yend = max(ds$value) + 0.004, colour = &quot;black&quot;) + annotate(&quot;text&quot;, x = 1.5, y = max(ds$value) + 0.007, label = paste0(&quot;p = &quot;, stats$p.adj[1])) + annotate(&quot;segment&quot;, x = 1, xend = 3, y = max(ds$value) + 0.01, yend = max(ds$value) + 0.01, colour = &quot;black&quot;) + annotate(&quot;segment&quot;, x = 1, xend = 1, y = max(ds$value) + 0.008, yend = max(ds$value) + 0.01, colour = &quot;black&quot;) + annotate(&quot;segment&quot;, x = 3, xend = 3, y = max(ds$value) + 0.008, yend = max(ds$value) + 0.01, colour = &quot;black&quot;) + annotate(&quot;text&quot;, x = 2, y = max(ds$value) + 0.013, label = paste0(&quot;p = &quot;, stats$p.adj[2])) + annotate(&quot;segment&quot;, x = 2.05, xend = 3, y = max(ds$value) + 0.004, yend = max(ds$value) + 0.004, colour = &quot;black&quot;) + annotate(&quot;segment&quot;, x = 2.05, xend = 2.05, y = max(ds$value) + 0.002, yend = max(ds$value) + 0.004, colour = &quot;black&quot;) + annotate(&quot;segment&quot;, x = 3, xend = 3, y = max(ds$value) + 0.002, yend = max(ds$value) + 0.004, colour = &quot;black&quot;) + annotate(&quot;text&quot;, x = 2.5, y = max(ds$value) + 0.007, label = paste0(&quot;p = &quot;, stats$p.adj[3])) + scale_fill_manual( breaks = c(&quot;Group 1&quot;, &quot;Group 2&quot;, &quot;Group 3&quot;), values = c(&quot;#03a1fc&quot;, &quot;#984EA3&quot;, &quot;#FF7F00&quot;), labels = c( &quot;Candidate antigen (Group 1)&quot;, &quot;Candidate antigen (Group 2)&quot;, &quot;Candidate antigen (Group 3)&quot; ) ) + theme_bw() + theme( panel.grid.major = element_blank(), panel.grid.minor = element_blank(), plot.margin = ggplot2::margin(5, 5, 38, 15, &quot;pt&quot;), axis.title = element_text(colour = &quot;black&quot;), axis.text.x = element_text(colour = &quot;black&quot;, angle = 45, vjust = 1, hjust = 1), axis.text.y = element_text(colour = &quot;black&quot;), plot.title = element_text(hjust = 0.5, colour = &quot;black&quot;), rect = element_rect(fill = &quot;transparent&quot;), legend.position = &quot;none&quot; ) + xlab(&quot;&quot;) + ylab(paste0(&quot;Difference in distances to &quot;, protein_name)) + ylim(ylim2) + ggtitle(&quot;&quot;) plots &lt;- list.append(plots, p) return(plots) } p1 &lt;- plot_grid(ggdraw() + draw_label(&quot;CSP (circumsporozoite protein); pre-erythrocytic stage&quot;), plot_grid( plotlist = plot_boxplots( protein_id = &quot;PF3D7_0304600.1-p1&quot;, protein_name = &quot;CSP&quot;, ylim1 = c(0.15, 0.7), ylim2 = c(-0.03, 0.04) ), nrow = 1, rel_widths = c(0.29, 0.22, 0.23, 0.48) ), ncol = 1, rel_heights = c(0.1, 1), labels = c(&quot;a&quot;, &quot;&quot;) ) p2 &lt;- plot_grid(ggdraw() + draw_label(&quot;RH5 (reticulocyte binding protein homologue 5); erythrocytic stage&quot;), plot_grid( plotlist = plot_boxplots( protein_id = &quot;PF3D7_0424100.1-p1&quot;, protein_name = &quot;RH5&quot;, ylim1 = c(0.15, 0.7), ylim2 = c(-0.03, 0.04) ), nrow = 1, rel_widths = c(0.29, 0.22, 0.23, 0.48) ), ncol = 1, rel_heights = c(0.1, 1), labels = c(&quot;b&quot;, &quot;&quot;) ) p3 &lt;- plot_grid(ggdraw() + draw_label(&quot;MSP5 (merozoite surface protein 5); erythrocytic stage&quot;), plot_grid( plotlist = plot_boxplots( protein_id = &quot;PF3D7_0206900.1-p1&quot;, protein_name = &quot;MSP5&quot;, ylim1 = c(0.15, 0.7), ylim2 = c(-0.03, 0.04) ), nrow = 1, rel_widths = c(0.29, 0.22, 0.23, 0.48) ), ncol = 1, rel_heights = c(0.1, 1), labels = c(&quot;c&quot;, &quot;&quot;) ) p4 &lt;- plot_grid(ggdraw() + draw_label(&quot;P230 (6-cysteine protein); gametocyte stage&quot;), plot_grid( plotlist = plot_boxplots( protein_id = &quot;PF3D7_0209000.1-p1&quot;, protein_name = &quot;P230&quot;, ylim1 = c(0.15, 0.7), ylim2 = c(-0.03, 0.04) ), nrow = 1, rel_widths = c(0.29, 0.22, 0.23, 0.48) ), ncol = 1, rel_heights = c(0.1, 1), labels = c(&quot;d&quot;, &quot;&quot;) ) Final plot p_combined &lt;- plot_grid(p1, p2, p3, p4, nrow = 2) p_combined 4.3 Important variables for candidate clustering groups Wilcox test to compare variable values in candidate groups and randomly selected proteins. 4.3.1 Analysis Permutation-based variable importance of candidate antigen groups. 4.3.1.1 Variable importance In R: data &lt;- read.csv(&quot;./other_data/pf_ml_input_processed_weighted.csv&quot;) load(file = &quot;./rdata/clustering_groups.RData&quot;) data_1 &lt;- data data_1$antigen_label &lt;- 0 data_1$antigen_label[data_1$X %in% protein_id_1] &lt;- 1 write.csv(data_1, &quot;./other_data/pf_ml_input_processed_weighted_group_1.csv&quot;, row.names = FALSE) data_2 &lt;- data data_2$antigen_label &lt;- 0 data_2$antigen_label[data_2$X %in% protein_id_2] &lt;- 1 write.csv(data_2, &quot;./other_data/pf_ml_input_processed_weighted_group_2.csv&quot;, row.names = FALSE) data_3 &lt;- data data_3$antigen_label &lt;- 0 data_3$antigen_label[data_3$X %in% protein_id_3] &lt;- 1 write.csv(data_3, &quot;./other_data/pf_ml_input_processed_weighted_group_3.csv&quot;, row.names = FALSE) In Python: import pickle import pandas as pd import numpy as np import pickle from sklearn.impute import SimpleImputer from sklearn.preprocessing import MinMaxScaler from scipy.spatial import distance import multiprocessing from joblib import Parallel, delayed num_cores = multiprocessing.cpu_count() from sklearn.ensemble._forest import _generate_unsampled_indices import session_info data_1 = pd.read_csv(&#39;./other_data/pf_ml_input_processed_weighted_group_1.csv&#39;, index_col=0) pf3d7_features_processed_1 = data_1.iloc[:,1:].apply(pd.to_numeric, downcast=&#39;float&#39;) pf3d7_outcome_1 = np.array(data_1.antigen_label) data_2 = pd.read_csv(&#39;./other_data/pf_ml_input_processed_weighted_group_2.csv&#39;, index_col=0) pf3d7_features_processed_2 = data_2.iloc[:,1:].apply(pd.to_numeric, downcast=&#39;float&#39;) pf3d7_outcome_2 = np.array(data_2.antigen_label) data_3 = pd.read_csv(&#39;./other_data/pf_ml_input_processed_weighted_group_3.csv&#39;, index_col=0) pf3d7_features_processed_3 = data_3.iloc[:,1:].apply(pd.to_numeric, downcast=&#39;float&#39;) pf3d7_outcome_3 = np.array(data_3.antigen_label) purf_model = pickle.load(open(&#39;./pickle_data/pf_purf_tree_filtering.pkl&#39;, &#39;rb&#39;)) purf = purf_model[&#39;model&#39;] weights = purf_model[&#39;weights&#39;] metadata = pd.read_csv(&#39;./data/supplementary_data_2_pf_protein_variable_metadata.csv&#39;) def calculate_raw_var_imp_(idx, tree, X, y, weight, groups=None): rng = np.random.RandomState(idx) oob_indices = _generate_unsampled_indices(tree.random_state, y.shape[0], y.shape[0]) oob_pos = np.intersect1d(oob_indices, np.where(y == 1)[0]) noutall = len(oob_pos) pred = tree.predict_proba(X.iloc[oob_pos,:])[:, 1] nrightall = sum(pred == y[oob_pos]) imprt, impsd = [], [] if groups is None: for var in range(X.shape[1]): X_temp = X.copy().iloc[oob_pos,:] X_temp.iloc[:, var] = rng.permutation(X_temp.iloc[:, var]) pred = tree.predict_proba(X_temp)[:, 1] nrightimpall = sum(pred == y[oob_pos]) delta = (nrightall - nrightimpall) / noutall * weight imprt.append(delta) impsd.append(delta * delta) else: for grp in np.unique(groups): X_temp = X.copy().iloc[oob_pos,:] X_temp.iloc[:, groups == grp] = rng.permutation(X_temp.iloc[:, groups == grp]) pred = tree.predict_proba(X_temp)[:, 1] nrightimpall = sum(pred == y[oob_pos]) delta = (nrightall - nrightimpall) / noutall * weight imprt.append(delta) impsd.append(delta * delta) return (imprt, impsd) def calculate_var_imp(model, features, outcome, num_cores, weights=None, groups=None): trees = model.estimators_ idx_list = [i for i in range(len(trees))] if weights is None: weights = np.ones(len(trees)) res = Parallel(n_jobs=num_cores)( delayed(calculate_raw_var_imp_)(idx, trees[idx], features, outcome, weights[idx], groups) for idx in idx_list) imprt, impsd = [], [] for i in range(len(idx_list)): imprt.append(res[i][0]) impsd.append(res[i][1]) imprt = np.array(imprt).sum(axis=0) impsd = np.array(impsd).sum(axis=0) imprt /= len(idx_list) impsd = np.sqrt(((impsd / len(idx_list)) - imprt * imprt) / len(idx_list)) mda = [] for i in range(len(imprt)): if impsd[i] != 0: mda.append(imprt[i] / impsd[i]) else: mda.append(imprt[i]) if groups is None: var_imp = pd.DataFrame({&#39;variable&#39;: features.columns, &#39;meanDecreaseAccuracy&#39;: mda}) else: var_imp = pd.DataFrame({&#39;variable&#39;: np.unique(groups), &#39;meanDecreaseAccuracy&#39;: mda}) return var_imp var_imp_1 = calculate_var_imp(purf, pf3d7_features_processed_1, pf3d7_outcome_1, num_cores, weights) var_imp_1.to_csv(&#39;./other_data/candidate_variable_importance_1.csv&#39;, index=False) var_imp_2 = calculate_var_imp(purf, pf3d7_features_processed_2, pf3d7_outcome_2, num_cores, weights) var_imp_2.to_csv(&#39;./other_data/candidate_variable_importance_2.csv&#39;, index=False) var_imp_3 = calculate_var_imp(purf, pf3d7_features_processed_3, pf3d7_outcome_3, num_cores, weights) var_imp_3.to_csv(&#39;./other_data/candidate_variable_importance_3.csv&#39;, index=False) 4.3.1.2 Wilcoxon test Variable value comparison between candidate antigens and other random proteins predicted as negative. In R: library(stringr) library(ggplot2) prediction &lt;- read.csv(&quot;./data/supplementary_data_4_purf_oob_predictions.csv&quot;) load(file = &quot;./rdata/clustering_groups.RData&quot;) other_proteins &lt;- prediction[prediction$antigen_label == 0 &amp; prediction$oob_score_with_tree_filtering &lt; 0.5, ]$protein_id set.seed(22) random_protein_1 &lt;- sample(other_proteins, size = length(protein_id_1), replace = FALSE) random_protein_2 &lt;- sample(other_proteins, size = length(protein_id_2), replace = FALSE) random_protein_3 &lt;- sample(other_proteins, size = length(protein_id_3), replace = FALSE) # Load imputed data data &lt;- read.csv(&quot;./other_data/pf_ml_input_processed_weighted.csv&quot;) data &lt;- data[!duplicated(data), ] compared_group_1 &lt;- sapply(data$X, function(x) if (x %in% protein_id_1) 1 else if (x %in% random_protein_1) 0 else -1) compared_group_2 &lt;- sapply(data$X, function(x) if (x %in% protein_id_2) 1 else if (x %in% random_protein_2) 0 else -1) compared_group_3 &lt;- sapply(data$X, function(x) if (x %in% protein_id_3) 1 else if (x %in% random_protein_3) 0 else -1) data &lt;- data[, 3:ncol(data)] # Min-max normalization min_max &lt;- function(x) { (x - min(x)) / (max(x) - min(x)) } data &lt;- data.frame(lapply(data, min_max)) save(compared_group_1, compared_group_2, compared_group_3, data, file = &quot;./rdata/candidate_antigen_wilcox_data.RData&quot;) pval &lt;- c() for (i in 1:ncol(data)) { pval &lt;- c(pval, wilcox.test(data[compared_group_1 == 1, i], data[compared_group_1 == 0, i])$p.value) } adj_pval &lt;- p.adjust(pval, method = &quot;BH&quot;, n = length(pval)) # adj_pval = -log10(adj_pval) wilcox_res &lt;- data.frame(variable = colnames(data), adj_pval = adj_pval) write.csv(wilcox_res, &quot;./other_data/candidate_antigen_wilcox_res_1.csv&quot;, row.names = FALSE) pval &lt;- c() for (i in 1:ncol(data)) { pval &lt;- c(pval, wilcox.test(data[compared_group_2 == 1, i], data[compared_group_2 == 0, i])$p.value) } adj_pval &lt;- p.adjust(pval, method = &quot;BH&quot;, n = length(pval)) # adj_pval = -log10(adj_pval) wilcox_res &lt;- data.frame(variable = colnames(data), adj_pval = adj_pval) write.csv(wilcox_res, &quot;./other_data/candidate_antigen_wilcox_res_2.csv&quot;, row.names = FALSE) pval &lt;- c() for (i in 1:ncol(data)) { pval &lt;- c(pval, wilcox.test(data[compared_group_3 == 1, i], data[compared_group_3 == 0, i])$p.value) } adj_pval &lt;- p.adjust(pval, method = &quot;BH&quot;, n = length(pval)) # adj_pval = -log10(adj_pval) wilcox_res &lt;- data.frame(variable = colnames(data), adj_pval = adj_pval) write.csv(wilcox_res, &quot;./other_data/candidate_antigen_wilcox_res_3.csv&quot;, row.names = FALSE) 4.3.2 Plotting In R: library(ggplot2) library(reshape2) library(cowplot) library(sfsmisc) library(stringr) firstup &lt;- function(x) { substr(x, 1, 1) &lt;- toupper(substr(x, 1, 1)) x } load(file = &quot;./rdata/candidate_antigen_wilcox_data.RData&quot;) wilcox_res &lt;- read.csv(&quot;./other_data/candidate_antigen_wilcox_res_1.csv&quot;) wilcox_data &lt;- data wilcox_data$compared_group &lt;- compared_group_1 var_imp &lt;- read.csv(&quot;./other_data/processed_candidate_variable_importance_1.csv&quot;, row.names = 1, check.names = FALSE) wilcox_data &lt;- wilcox_data[wilcox_data$compared_group != -1, ] wilcox_data &lt;- melt(wilcox_data, id = c(&quot;compared_group&quot;)) wilcox_data &lt;- merge(x = wilcox_data, y = merge(x = var_imp, y = wilcox_res, by.x = &quot;row.names&quot;, by.y = &quot;variable&quot;), by.x = &quot;variable&quot;, by.y = &quot;Row.names&quot;, all.y = TRUE) wilcox_data$tile_pos &lt;- rep(0, nrow(wilcox_data)) wilcox_data$compared_group &lt;- factor(wilcox_data$compared_group) wilcox_data$variable &lt;- sapply(wilcox_data$variable, function(x) { x &lt;- str_replace_all(x, &quot;[_\\\\.]&quot;, &quot; &quot;) x &lt;- firstup(x) return(x) }) adj_pval_tmp &lt;- c() for (i in 1:nrow(wilcox_data)) { x &lt;- wilcox_data$adj_pval[i] if (x &gt;= 1e-3) { res &lt;- paste0(&quot;italic(p) == &quot;, round(x, 3)) } else { a &lt;- strsplit(format(x, scientific = TRUE, digits = 2), &quot;e&quot;)[[1]] res &lt;- paste0(&quot;italic(p) == &quot;, as.numeric(a[1]), &quot; %*% 10^&quot;, as.integer(a[2])) } adj_pval_tmp &lt;- c(adj_pval_tmp, res) } wilcox_data$adj_pval &lt;- adj_pval_tmp p1 &lt;- ggplot(wilcox_data, aes(x = reorder(variable, `Mean decrease accuracy`), y = value, fill = compared_group)) + geom_boxplot(outlier.color = NA, alpha = 0.3, lwd = 0.3) + geom_point( color = &quot;black&quot;, shape = 21, stroke = 0.3, alpha = 0.5, size = 0.5, position = position_jitterdodge() ) + geom_text(aes(label = adj_pval), y = 1.1, size = 3, fontface = &quot;plain&quot;, family = &quot;sans&quot;, hjust = 0, parse = TRUE) + geom_vline(xintercept = 1:9 + 0.5, color = &quot;grey80&quot;, linetype = &quot;solid&quot;, size = 0.1) + scale_x_discrete( breaks = sapply(c( &quot;nonsynonymous_snps&quot;, &quot;max_karplus_schulz_flexibility&quot;, &quot;max_parker_hydrophilicity&quot;, &quot;PmN&quot;, &quot;mitochondrial&quot;, &quot;avg_parker_hydrophilicity&quot;, &quot;hydrophobicity_Group3&quot;, &quot;total_snps&quot;, &quot;min_score_ifn_epitopes&quot;, &quot;pi_value&quot; ), function(x) { x &lt;- str_replace_all(x, &quot;[_\\\\.]&quot;, &quot; &quot;) x &lt;- firstup(x) return(x) }), labels = c( &quot;Number non-synonymous SNPs&quot;, &quot;Maximum score of Karplus and Schulz flexibility&quot;, &quot;Maximum score of Parker hydrophilicity&quot;, expression(&quot;% positive charge a.a. - % negative charge a.a.&quot;), &quot;Mitochondrial&quot;, &quot;Average score of Parker hydrophilicity&quot;, expression(&quot;% hydrophobicity amino acids&quot;), &quot;Total number of SNPs&quot;, &quot;Minimum score of IFN-gamma inducing epitopes&quot;, &quot;Isoelectric point (PI) value&quot; ) ) + coord_flip(ylim = c(0, 1), clip = &quot;off&quot;) + scale_fill_manual( breaks = c(&quot;1&quot;, &quot;0&quot;), values = c(&quot;red&quot;, &quot;blue&quot;), labels = c(&quot;Candidate antigens&quot;, &quot;Random predicted non-antigens&quot;) ) + theme_bw() + xlab(&quot;&quot;) + ylab(&quot;Normalized variable value&quot;) + ylim(0, 1) + ggtitle(&quot;Group 1 (61 candidates)&quot;) legend &lt;- get_legend(p1 + theme( legend.title = element_blank(), legend.background = element_blank(), legend.key = element_blank(), legend.direction = &quot;horizontal&quot;, legend.position = c(0.35, 0.9) )) p1 &lt;- p1 + theme( panel.grid.major = element_blank(), panel.grid.minor = element_blank(), strip.background = element_blank(), panel.border = element_rect(colour = &quot;black&quot;), plot.title = element_text(hjust = 0.5), plot.margin = ggplot2::margin(10, 70, 5, 30, &quot;pt&quot;), legend.text = element_text(colour = &quot;black&quot;), axis.title.x = element_text(color = &quot;black&quot;), axis.title.y = element_text(color = &quot;black&quot;), axis.text.x = element_text(color = &quot;black&quot;), axis.text.y = element_text(color = &quot;black&quot;), legend.position = &quot;none&quot; ) wilcox_res &lt;- read.csv(&quot;./other_data/candidate_antigen_wilcox_res_2.csv&quot;) wilcox_data &lt;- data wilcox_data$compared_group &lt;- compared_group_2 var_imp &lt;- read.csv(&quot;./other_data/processed_candidate_variable_importance_2.csv&quot;, row.names = 1, check.names = FALSE) wilcox_data &lt;- wilcox_data[wilcox_data$compared_group != -1, ] wilcox_data &lt;- melt(wilcox_data, id = c(&quot;compared_group&quot;)) wilcox_data &lt;- merge(x = wilcox_data, y = merge(x = var_imp, y = wilcox_res, by.x = &quot;row.names&quot;, by.y = &quot;variable&quot;), by.x = &quot;variable&quot;, by.y = &quot;Row.names&quot;, all.y = TRUE) wilcox_data$tile_pos &lt;- rep(0, nrow(wilcox_data)) wilcox_data$compared_group &lt;- factor(wilcox_data$compared_group) wilcox_data$variable &lt;- sapply(wilcox_data$variable, function(x) { x &lt;- str_replace_all(x, &quot;[_\\\\.]&quot;, &quot; &quot;) x &lt;- firstup(x) return(x) }) adj_pval_tmp &lt;- c() for (i in 1:nrow(wilcox_data)) { x &lt;- wilcox_data$adj_pval[i] if (x &gt;= 1e-3) { res &lt;- paste0(&quot;italic(p) == &quot;, round(x, 3)) } else { a &lt;- strsplit(format(x, scientific = TRUE, digits = 2), &quot;e&quot;)[[1]] res &lt;- paste0(&quot;italic(p) == &quot;, as.numeric(a[1]), &quot; %*% 10^&quot;, as.integer(a[2])) } adj_pval_tmp &lt;- c(adj_pval_tmp, res) } wilcox_data$adj_pval &lt;- adj_pval_tmp p2 &lt;- ggplot(wilcox_data, aes(x = reorder(variable, `Mean decrease accuracy`), y = value, fill = compared_group)) + geom_boxplot(outlier.color = NA, alpha = 0.3, lwd = 0.3) + geom_point( color = &quot;black&quot;, shape = 21, stroke = 0.3, alpha = 0.5, size = 0.5, position = position_jitterdodge() ) + geom_text(aes(label = adj_pval), y = 1.1, size = 3, fontface = &quot;plain&quot;, family = &quot;sans&quot;, hjust = 0, parse = TRUE) + geom_vline(xintercept = 1:9 + 0.5, color = &quot;grey80&quot;, linetype = &quot;solid&quot;, size = 0.1) + scale_x_discrete( breaks = sapply(c( &quot;max_parker_hydrophilicity&quot;, &quot;nonsynonymous_snps&quot;, &quot;max_karplus_schulz_flexibility&quot;, &quot;cytoskeletal&quot;, &quot;mitochondrial&quot;, &quot;hydrophobicity_Group3&quot;, &quot;min_score_ifn_epitopes&quot;, &quot;PmN&quot;, &quot;total_snps&quot;, &quot;avg_parker_hydrophilicity&quot; ), function(x) { x &lt;- str_replace_all(x, &quot;[_\\\\.]&quot;, &quot; &quot;) x &lt;- firstup(x) return(x) }), labels = c( &quot;Maximum score of Parker hydrophilicity&quot;, &quot;Number non-synonymous SNPs&quot;, &quot;Maximum score of Karplus and Schulz flexibility&quot;, &quot;Cytoskeletal&quot;, &quot;Mitochondrial&quot;, &quot;% hydrophobicity amino acids&quot;, &quot;Minimum score of IFN-gamma inducing epitopes&quot;, expression(&quot;% positive charge a.a. - % negative charge a.a.&quot;), &quot;Total number of SNPs&quot;, &quot;Average score of Parker hydrophilicity&quot; ) ) + coord_flip(ylim = c(0, 1), clip = &quot;off&quot;) + scale_fill_manual( breaks = c(&quot;1&quot;, &quot;0&quot;), values = c(&quot;red&quot;, &quot;blue&quot;), labels = c(&quot;Candidate antigens&quot;, &quot;Random predicted non-antigens&quot;) ) + theme_bw() + theme( panel.grid.major = element_blank(), panel.grid.minor = element_blank(), strip.background = element_blank(), panel.border = element_rect(colour = &quot;black&quot;), plot.title = element_text(hjust = 0.5), plot.margin = ggplot2::margin(10, 70, 5, 0, &quot;pt&quot;), legend.text = element_text(colour = &quot;black&quot;), axis.title.x = element_text(color = &quot;black&quot;), axis.title.y = element_text(color = &quot;black&quot;), axis.text.x = element_text(color = &quot;black&quot;), axis.text.y = element_text(color = &quot;black&quot;), legend.position = &quot;none&quot; ) + xlab(&quot;&quot;) + ylab(&quot;Normalized variable value&quot;) + ggtitle(&quot;Group 2 (83 candidates)&quot;) wilcox_res &lt;- read.csv(&quot;./other_data/candidate_antigen_wilcox_res_3.csv&quot;) wilcox_data &lt;- data wilcox_data$compared_group &lt;- compared_group_3 var_imp &lt;- read.csv(&quot;./other_data/processed_candidate_variable_importance_3.csv&quot;, row.names = 1, check.names = FALSE) wilcox_data &lt;- wilcox_data[wilcox_data$compared_group != -1, ] wilcox_data &lt;- melt(wilcox_data, id = c(&quot;compared_group&quot;)) wilcox_data &lt;- merge(x = wilcox_data, y = merge(x = var_imp, y = wilcox_res, by.x = &quot;row.names&quot;, by.y = &quot;variable&quot;), by.x = &quot;variable&quot;, by.y = &quot;Row.names&quot;, all.y = TRUE) wilcox_data$tile_pos &lt;- rep(0, nrow(wilcox_data)) wilcox_data$compared_group &lt;- factor(wilcox_data$compared_group) wilcox_data$variable &lt;- sapply(wilcox_data$variable, function(x) { x &lt;- str_replace_all(x, &quot;[_\\\\.]&quot;, &quot; &quot;) x &lt;- firstup(x) return(x) }) adj_pval_tmp &lt;- c() for (i in 1:nrow(wilcox_data)) { x &lt;- wilcox_data$adj_pval[i] if (x &gt;= 1e-3) { res &lt;- paste0(&quot;italic(p) == &quot;, round(x, 3)) } else { a &lt;- strsplit(format(x, scientific = TRUE, digits = 2), &quot;e&quot;)[[1]] res &lt;- paste0(&quot;italic(p) == &quot;, as.numeric(a[1]), &quot; %*% 10^&quot;, as.integer(a[2])) } adj_pval_tmp &lt;- c(adj_pval_tmp, res) } wilcox_data$adj_pval &lt;- adj_pval_tmp p3 &lt;- ggplot(wilcox_data, aes(x = reorder(variable, `Mean decrease accuracy`), y = value, fill = compared_group)) + geom_boxplot(outlier.color = NA, alpha = 0.3, lwd = 0.3) + geom_point( color = &quot;black&quot;, shape = 21, stroke = 0.3, alpha = 0.5, size = 0.5, position = position_jitterdodge() ) + geom_text(aes(label = adj_pval), y = 1.1, size = 3, fontface = &quot;plain&quot;, family = &quot;sans&quot;, hjust = 0, parse = TRUE) + geom_vline(xintercept = 1:9 + 0.5, color = &quot;grey80&quot;, linetype = &quot;solid&quot;, size = 0.1) + scale_x_discrete( breaks = sapply(c( &quot;out_number_b_cell_epitopes_bepipred_1_0&quot;, &quot;max_parker_hydrophilicity&quot;, &quot;max_karplus_schulz_flexibility&quot;, &quot;nonsynonymous_snps&quot;, &quot;hydrophobicity_Group3&quot;, &quot;cytoskeletal&quot;, &quot;mitochondrial&quot;, &quot;PmN&quot;, &quot;avg_parker_hydrophilicity&quot;, &quot;min_parker_hydrophilicity&quot; ), function(x) { x &lt;- str_replace_all(x, &quot;[_\\\\.]&quot;, &quot; &quot;) x &lt;- firstup(x) return(x) }), labels = c( &quot;Number B-cell epitopes in outer membrane regions&quot;, &quot;Maximum score of Parker hydrophilicity&quot;, &quot;Maximum score of Karplus and Schulz flexibility&quot;, &quot;Number non-synonymous SNPs&quot;, expression(&quot;% hydrophobicity amino acids&quot;), &quot;Cytoskeletal&quot;, &quot;Mitochondrial&quot;, expression(&quot;% positive charge a.a. - % negative charge a.a.&quot;), &quot;Average score of Parker hydrophilicity&quot;, &quot;Minimum score of Parker hydrophilicity&quot; ) ) + coord_flip(ylim = c(0, 1), clip = &quot;off&quot;) + scale_fill_manual( breaks = c(&quot;1&quot;, &quot;0&quot;), values = c(&quot;red&quot;, &quot;blue&quot;), labels = c(&quot;Candidate antigens&quot;, &quot;Random predicted non-antigens&quot;) ) + theme_bw() + theme( panel.grid.major = element_blank(), panel.grid.minor = element_blank(), strip.background = element_blank(), panel.border = element_rect(colour = &quot;black&quot;), plot.title = element_text(hjust = 0.5), plot.margin = ggplot2::margin(10, 70, 5, 20, &quot;pt&quot;), legend.text = element_text(colour = &quot;black&quot;), axis.title.x = element_text(color = &quot;black&quot;), axis.title.y = element_text(color = &quot;black&quot;), axis.text.x = element_text(color = &quot;black&quot;), axis.text.y = element_text(color = &quot;black&quot;), legend.position = &quot;none&quot; ) + xlab(&quot;&quot;) + ylab(&quot;Normalized variable value&quot;) + ylim(0, 1) + ggtitle(&quot;Group 3 (56 candidates)&quot;) Final plot p_combined &lt;- plot_grid(plot_grid(p1, p3, ncol = 1, rel_heights = c(0.5, 0.5)), plot_grid(p2, NULL, plot_grid(NULL, legend, nrow = 1, rel_widths = c(0.45, 0.6)), NULL, ncol = 1, rel_heights = c(0.5, 0.02, 0.1, 0.4) ), nrow = 1, rel_widths = c(0.52, 0.48) ) p_combined 4.4 Comparison of important variables In R: var_imp_1 &lt;- read.csv(&quot;./other_data/candidate_variable_importance_1.csv&quot;, row.names = 1) var_imp_2 &lt;- read.csv(&quot;./other_data/candidate_variable_importance_2.csv&quot;, row.names = 1) var_imp_3 &lt;- read.csv(&quot;./other_data/candidate_variable_importance_3.csv&quot;, row.names = 1) var_imp_1 &lt;- var_imp_1[order(-var_imp_1$meanDecreaseAccuracy), , drop = FALSE] var_imp_2 &lt;- var_imp_2[order(-var_imp_2$meanDecreaseAccuracy), , drop = FALSE] var_imp_3 &lt;- var_imp_3[order(-var_imp_3$meanDecreaseAccuracy), , drop = FALSE] var_imp_1$rank_1 &lt;- rank(-var_imp_1$meanDecreaseAccuracy) var_imp_2$rank_2 &lt;- rank(-var_imp_2$meanDecreaseAccuracy) var_imp_3$rank_3 &lt;- rank(-var_imp_3$meanDecreaseAccuracy) var_imp_1$rank_2 &lt;- var_imp_2[rownames(var_imp_1), &quot;rank_2&quot;] var_imp_1$rank_3 &lt;- var_imp_3[rownames(var_imp_1), &quot;rank_3&quot;] var_imp_2$rank_1 &lt;- var_imp_1[rownames(var_imp_2), &quot;rank_1&quot;] var_imp_2$rank_3 &lt;- var_imp_3[rownames(var_imp_2), &quot;rank_3&quot;] var_imp_3$rank_1 &lt;- var_imp_1[rownames(var_imp_3), &quot;rank_1&quot;] var_imp_3$rank_2 &lt;- var_imp_2[rownames(var_imp_3), &quot;rank_2&quot;] grp_var_imp_1 &lt;- read.csv(&quot;./other_data/candidate_group_variable_importance_1.csv&quot;, row.names = 1) grp_var_imp_2 &lt;- read.csv(&quot;./other_data/candidate_group_variable_importance_2.csv&quot;, row.names = 1) grp_var_imp_3 &lt;- read.csv(&quot;./other_data/candidate_group_variable_importance_3.csv&quot;, row.names = 1) grp_var_imp_1 &lt;- grp_var_imp_1[order(-grp_var_imp_1$meanDecreaseAccuracy), , drop = FALSE] grp_var_imp_2 &lt;- grp_var_imp_2[order(-grp_var_imp_2$meanDecreaseAccuracy), , drop = FALSE] grp_var_imp_3 &lt;- grp_var_imp_3[order(-grp_var_imp_3$meanDecreaseAccuracy), , drop = FALSE] grp_var_imp_1$rank_1 &lt;- rank(-grp_var_imp_1$meanDecreaseAccuracy) grp_var_imp_2$rank_2 &lt;- rank(-grp_var_imp_2$meanDecreaseAccuracy) grp_var_imp_3$rank_3 &lt;- rank(-grp_var_imp_3$meanDecreaseAccuracy) grp_var_imp_1$rank_2 &lt;- grp_var_imp_2[rownames(grp_var_imp_1), &quot;rank_2&quot;] grp_var_imp_1$rank_3 &lt;- grp_var_imp_3[rownames(grp_var_imp_1), &quot;rank_3&quot;] grp_var_imp_2$rank_1 &lt;- grp_var_imp_1[rownames(grp_var_imp_2), &quot;rank_1&quot;] grp_var_imp_2$rank_3 &lt;- grp_var_imp_3[rownames(grp_var_imp_2), &quot;rank_3&quot;] grp_var_imp_3$rank_1 &lt;- grp_var_imp_1[rownames(grp_var_imp_3), &quot;rank_1&quot;] grp_var_imp_3$rank_2 &lt;- grp_var_imp_2[rownames(grp_var_imp_3), &quot;rank_2&quot;] var_imp_1_ &lt;- rbind(var_imp_1[1:10, c(&quot;meanDecreaseAccuracy&quot;, &quot;rank_2&quot;, &quot;rank_3&quot;)], grp_var_imp_1[, c(&quot;meanDecreaseAccuracy&quot;, &quot;rank_2&quot;, &quot;rank_3&quot;)]) colnames(var_imp_1_) &lt;- c(&quot;Mean decrease accuracy&quot;, &quot;Group 2 rank&quot;, &quot;Group 3 rank&quot;) write.csv(var_imp_1_, &quot;./other_data/processed_candidate_variable_importance_1.csv&quot;, row.names = TRUE) var_imp_2_ &lt;- rbind(var_imp_2[1:10, c(&quot;meanDecreaseAccuracy&quot;, &quot;rank_1&quot;, &quot;rank_3&quot;)], grp_var_imp_2[, c(&quot;meanDecreaseAccuracy&quot;, &quot;rank_1&quot;, &quot;rank_3&quot;)]) colnames(var_imp_2_) &lt;- c(&quot;Mean decrease accuracy&quot;, &quot;Group 1 rank&quot;, &quot;Group 3 rank&quot;) write.csv(var_imp_2_, &quot;./other_data/processed_candidate_variable_importance_2.csv&quot;, row.names = TRUE) var_imp_3_ &lt;- rbind(var_imp_3[1:10, c(&quot;meanDecreaseAccuracy&quot;, &quot;rank_1&quot;, &quot;rank_2&quot;)], grp_var_imp_3[, c(&quot;meanDecreaseAccuracy&quot;, &quot;rank_1&quot;, &quot;rank_2&quot;)]) colnames(var_imp_3_) &lt;- c(&quot;Mean decrease accuracy&quot;, &quot;Group 1 rank&quot;, &quot;Group 2 rank&quot;) write.csv(var_imp_3_, &quot;./other_data/processed_candidate_variable_importance_3.csv&quot;, row.names = TRUE) Group 1 Group 2 Group 3 sessionInfo() ## R version 4.2.3 (2023-03-15) ## Platform: x86_64-apple-darwin17.0 (64-bit) ## Running under: macOS Big Sur ... 10.16 ## ## Matrix products: default ## BLAS: /Library/Frameworks/R.framework/Versions/4.2/Resources/lib/libRblas.0.dylib ## LAPACK: /Library/Frameworks/R.framework/Versions/4.2/Resources/lib/libRlapack.dylib ## ## locale: ## [1] en_US.UTF-8/en_US.UTF-8/en_US.UTF-8/C/en_US.UTF-8/en_US.UTF-8 ## ## attached base packages: ## [1] stats graphics grDevices utils datasets methods base ## ## other attached packages: ## [1] sfsmisc_1.1-13 umap_0.2.8.0 cluster_2.1.4 ggforce_0.3.4 ## [5] ggbeeswarm_0.6.0 ggpubr_0.4.0 rlist_0.4.6.2 reshape2_1.4.4 ## [9] cowplot_1.1.1 ggrepel_0.9.1 stringr_1.4.1 NbClust_3.0.1 ## [13] factoextra_1.0.7 ggplot2_3.4.2 ## ## loaded via a namespace (and not attached): ## [1] sass_0.4.2 tidyr_1.2.0 jsonlite_1.8.0 carData_3.0-5 ## [5] R.utils_2.12.0 bslib_0.4.0 assertthat_0.2.1 askpass_1.1 ## [9] highr_0.9 vipor_0.4.5 yaml_2.3.5 pillar_1.8.1 ## [13] backports_1.4.1 lattice_0.20-45 glue_1.6.2 reticulate_1.25 ## [17] digest_0.6.29 ggsignif_0.6.3 polyclip_1.10-0 colorspace_2.0-3 ## [21] htmltools_0.5.3 Matrix_1.5-3 R.oo_1.25.0 plyr_1.8.7 ## [25] pkgconfig_2.0.3 broom_1.0.0 bookdown_0.28 purrr_0.3.4 ## [29] scales_1.2.1 RSpectra_0.16-1 tweenr_2.0.1 openssl_2.0.2 ## [33] tibble_3.1.8 styler_1.8.0 generics_0.1.3 farver_2.1.1 ## [37] car_3.1-0 cachem_1.0.6 withr_2.5.0 cli_3.6.1 ## [41] magrittr_2.0.3 evaluate_0.16 R.methodsS3_1.8.2 fansi_1.0.3 ## [45] R.cache_0.16.0 MASS_7.3-58.2 rstatix_0.7.0 beeswarm_0.4.0 ## [49] tools_4.2.3 data.table_1.14.2 lifecycle_1.0.3 munsell_0.5.0 ## [53] compiler_4.2.3 jquerylib_0.1.4 rlang_1.1.0 grid_4.2.3 ## [57] rstudioapi_0.14 rmarkdown_2.16 codetools_0.2-19 gtable_0.3.0 ## [61] abind_1.4-5 DBI_1.1.3 R6_2.5.1 knitr_1.40 ## [65] dplyr_1.0.9 fastmap_1.1.0 utf8_1.2.2 stringi_1.7.8 ## [69] Rcpp_1.0.9 vctrs_0.6.2 png_0.1-7 tidyselect_1.1.2 ## [73] xfun_0.32 "],["id_05_further_characterization.html", "Section 5 Further characterization 5.1 Gene ontology analysis 5.2 Candidate antigen characterization", " Section 5 Further characterization 5.1 Gene ontology analysis Gene ontology (GO) enrichment analysis using GOATOOLS (Klopfenstein et al. 2018). 5.1.1 Analysis In bash: python ./other_data/goea.py -s &quot;./other_data/top_200_candidates_gene_accession_1.csv&quot; \\ -p &quot;./other_data/PlasmoDB-59_Pfalciparum3D7_GO.gaf&quot; \\ -n &quot;./other_data/go-basic.obo&quot; \\ -o &quot;./other_data/goea_result_1.xlsx&quot; python ./other_data/goea.py -s &quot;./other_data/top_200_candidates_gene_accession_2.csv&quot; \\ -p &quot;./other_data/PlasmoDB-59_Pfalciparum3D7_GO.gaf&quot; \\ -n &quot;./other_data/go-basic.obo&quot; \\ -o &quot;./other_data/goea_result_2.xlsx&quot; python ./other_data/goea.py -s &quot;./other_data/top_200_candidates_gene_accession_3.csv&quot; \\ -p &quot;./other_data/PlasmoDB-59_Pfalciparum3D7_GO.gaf&quot; \\ -n &quot;./other_data/go-basic.obo&quot; \\ -o &quot;./other_data/goea_result_3.xlsx&quot; 5.1.2 Plotting In R: library(ggplot2) library(gridExtra) library(shadowtext) library(ggforce) library(reshape) library(cowplot) process_goea_res &lt;- function(file_name) { data &lt;- read.csv(file_name, header = TRUE, fill = TRUE, quote = &#39;\\&quot;&#39;, stringsAsFactors = FALSE) # calculate percentage from the ratio column data$num_genes &lt;- apply(data, 1, function(x) as.integer(unlist(strsplit(x[&quot;ratio_in_study&quot;], &quot;/&quot;))[1])) # select for enrichment (e) data rows data &lt;- data[data$enrichment == &quot;e&quot;, ] # select for biological process (BP) data rows res_bp &lt;- data[data$NS == &quot;BP&quot;, ] res_bp$`-Log10FDR` &lt;- -log10(res_bp$p_fdr_bh) res_bp &lt;- res_bp[order(res_bp$`-Log10FDR`), ] res_bp$group &lt;- rep(&quot;Biological process&quot;, nrow(res_bp)) # select for cellular component (CC) data rows res_cc &lt;- data[data$NS == &quot;CC&quot;, ] res_cc$`-Log10FDR` &lt;- -log10(res_cc$p_fdr_bh) res_cc &lt;- res_cc[order(res_cc$`-Log10FDR`), ] res_cc$group &lt;- rep(&quot;Cellular component&quot;, nrow(res_cc)) # select for molecular function (MF) data rows res_mf &lt;- data[data$NS == &quot;MF&quot;, ] res_mf$`-Log10FDR` &lt;- -log10(res_mf$p_fdr_bh) res_mf &lt;- res_mf[order(res_mf$`-Log10FDR`), ] res_mf$group &lt;- rep(&quot;Molecular function&quot;, nrow(res_mf)) ds &lt;- do.call(rbind, list(res_mf, res_cc, res_bp)) ds$name &lt;- factor(ds$name, levels = ds$name) ds$group &lt;- factor(ds$group, levels = c(&quot;Biological process&quot;, &quot;Cellular component&quot;, &quot;Molecular function&quot;)) return(ds) } ds_1 &lt;- process_goea_res(&quot;./other_data/goea_result_1.csv&quot;) ds_2 &lt;- process_goea_res(&quot;./other_data/goea_result_2.csv&quot;) ds_3 &lt;- process_goea_res(&quot;./other_data/goea_result_3.csv&quot;) p1 &lt;- ggplot(ds_1, aes(x = name, y = `-Log10FDR`)) + geom_col(width = 0.05) + geom_point(size = 5, shape = 21, color = &quot;black&quot;, fill = &quot;grey20&quot;) + geom_text(aes(label = sprintf(&quot;%.0f&quot;, num_genes)), nudge_y = 0, size = 2.5, color = &quot;white&quot;) + coord_flip() + ggforce::facet_col(facets = vars(group), scales = &quot;free_y&quot;, space = &quot;free&quot;) + theme_bw() + theme( panel.grid.major = element_blank(), panel.grid.minor = element_blank(), panel.spacing = unit(0, &quot;pt&quot;), strip.background = element_blank(), panel.border = element_rect(colour = &quot;black&quot;, size = 0.5), plot.title = element_text(hjust = 0.5), plot.margin = ggplot2::margin(5, 5, 85, 5, &quot;pt&quot;), legend.text = element_text(colour = &quot;black&quot;, ), axis.title.x = element_text(colour = &quot;black&quot;, ), axis.title.y = element_text(colour = &quot;black&quot;, ), axis.text.x = element_text(colour = &quot;black&quot;, ), axis.text.y = element_text(colour = &quot;black&quot;, ) ) + xlab(&quot;&quot;) + ylab(expression(&quot;-Log&quot;[10] * &quot;FDR&quot;)) + ggtitle(&quot;Group 1 (61 candidates)&quot;) p2 &lt;- ggplot(ds_2, aes(x = name, y = `-Log10FDR`)) + geom_col(width = 0.05) + geom_point(size = 5, shape = 21, color = &quot;black&quot;, fill = &quot;grey20&quot;) + geom_text(aes(label = sprintf(&quot;%.0f&quot;, num_genes)), nudge_y = 0, size = 2.5, color = &quot;white&quot;) + coord_flip() + ggforce::facet_col(facets = vars(group), scales = &quot;free_y&quot;, space = &quot;free&quot;) + theme_bw() + theme( panel.grid.major = element_blank(), panel.grid.minor = element_blank(), panel.spacing = unit(0, &quot;pt&quot;), strip.background = element_blank(), panel.border = element_rect(colour = &quot;black&quot;, size = 0.5), plot.title = element_text(hjust = 0.5), plot.margin = ggplot2::margin(5, 0, 5, 5, &quot;pt&quot;), legend.text = element_text(colour = &quot;black&quot;, ), axis.title.x = element_text(colour = &quot;black&quot;, ), axis.title.y = element_text(colour = &quot;black&quot;, ), axis.text.x = element_text(colour = &quot;black&quot;, ), axis.text.y = element_text(colour = &quot;black&quot;, ) ) + xlab(&quot;&quot;) + ylab(expression(&quot;-Log&quot;[10] * &quot;FDR&quot;)) + ggtitle(&quot;Group 2 (83 candidates)&quot;) p3 &lt;- ggplot(ds_3, aes(x = name, y = `-Log10FDR`)) + geom_col(width = 0.05) + geom_point(size = 5, shape = 21, color = &quot;black&quot;, fill = &quot;grey20&quot;) + geom_text(aes(label = sprintf(&quot;%.0f&quot;, num_genes)), nudge_y = 0, size = 2.5, color = &quot;white&quot;) + coord_flip() + ggforce::facet_col(facets = vars(group), scales = &quot;free_y&quot;, space = &quot;free&quot;) + theme_bw() + theme( panel.grid.major = element_blank(), panel.grid.minor = element_blank(), panel.spacing = unit(0, &quot;pt&quot;), strip.background = element_blank(), panel.border = element_rect(colour = &quot;black&quot;, size = 0.5), plot.title = element_text(hjust = 0.5), plot.margin = ggplot2::margin(5, 5, 5, 0, &quot;pt&quot;), legend.text = element_text(colour = &quot;black&quot;, ), axis.title.x = element_text(colour = &quot;black&quot;, ), axis.title.y = element_text(colour = &quot;black&quot;, ), axis.text.x = element_text(colour = &quot;black&quot;, ), axis.text.y = element_text(colour = &quot;black&quot;, ) ) + xlab(&quot;&quot;) + ylab(expression(&quot;-Log&quot;[10] * &quot;FDR&quot;)) + ggtitle(&quot;Group 3 (56 candidates)&quot;) Final plot p_combined &lt;- plot_grid(p1, p2, p3, nrow = 1, rel_widths = c(0.39, 0.34, 0.4)) p_combined 5.2 Candidate antigen characterization Candidate antigen down-selection with essential genes (Zhang et al. 2018) and characterization using single cell RNA-seq data (Howick et al. 2019). 5.2.1 Analysis In R: 5.2.1.1 Down-selection with essential genes library(RMariaDB) library(DBI) db &lt;- dbConnect(RMariaDB::MariaDB(), user = &quot;root&quot;, password = &quot;&quot;, dbname = &quot;pf_reverse_vaccinology&quot;) get_data &lt;- function(table_name, db) { sql &lt;- sqlInterpolate(db, &quot;SELECT * FROM ?table&quot;, table = dbQuoteIdentifier(db, table_name)) return(subset(dbGetQuery(db, sql), select = -c(id))) } # pf3d7_essential_gene id_map &lt;- dbGetQuery(db, &#39;SELECT dbxref_1.accession AS accession, dbxref_1.dbxref_id AS transcript_id FROM dbxref AS dbxref_1 LEFT OUTER JOIN feature AS feature_1 ON dbxref_1.dbxref_id = feature_1.dbxref_id LEFT OUTER JOIN cvterm ON feature_1.type_id = cvterm.cvterm_id LEFT OUTER JOIN feature_relationship ON feature_1.feature_id = feature_relationship.subject_id LEFT OUTER JOIN feature AS feature_2 ON feature_relationship.object_id = feature_2.feature_id LEFT OUTER JOIN dbxref AS dbxref_2 ON feature_2.dbxref_id = dbxref_2.dbxref_id LEFT OUTER JOIN organism ON feature_1.organism_id = organism.organism_id WHERE feature_1.is_obsolete = 0 AND cvterm.name = &quot;CDS&quot; AND organism.species=&quot;falciparum_3D7&quot;&#39;) data &lt;- get_data(&quot;pf3d7_essential_gene&quot;, db) data &lt;- merge(x = id_map, y = data, by = &quot;transcript_id&quot;, all = FALSE) accession &lt;- data$accession data &lt;- subset(data, select = -c(transcript_id, accession)) rownames(data) &lt;- accession write.csv(data, file = &quot;./other_data/pf_essential_genes.csv&quot;) dbDisconnect(db) 5.2.1.2 Characterization using scRNA-seq # db = dbConnect(RMariaDB::MariaDB(), user=&#39;root&#39;, password=&#39;&#39;, dbname = &#39;pf_reverse_vaccinology&#39;) # # get_data = function(table_name, db) { # sql = sqlInterpolate(db, &#39;SELECT * FROM ?table&#39;, table=dbQuoteIdentifier(db, table_name)) # return(subset(dbGetQuery(db, sql), select = -c(id))) # } # # # scRNA-seq metadata # sc_metadata = get_data(&quot;pf3d7_single_cell_coldata&quot;, db) # rownames(sc_metadata) = sc_metadata[, 1] # sc_metadata[, 1] = NULL # write.csv(sc_metadata, file=&#39;./other_data/pf_sc_metadata.csv&#39;) # # # scRNA-seq count data # id_map = dbGetQuery(db, &#39;SELECT dbxref_1.accession AS accession, dbxref_1.dbxref_id AS transcript_id FROM dbxref AS dbxref_1 # LEFT OUTER JOIN feature AS feature_1 ON dbxref_1.dbxref_id = feature_1.dbxref_id # LEFT OUTER JOIN cvterm ON feature_1.type_id = cvterm.cvterm_id # LEFT OUTER JOIN feature_relationship ON feature_1.feature_id = feature_relationship.subject_id # LEFT OUTER JOIN feature AS feature_2 ON feature_relationship.object_id = feature_2.feature_id # LEFT OUTER JOIN dbxref AS dbxref_2 ON feature_2.dbxref_id = dbxref_2.dbxref_id # LEFT OUTER JOIN organism ON feature_1.organism_id = organism.organism_id # WHERE feature_1.is_obsolete = 0 AND cvterm.name = &quot;CDS&quot; AND organism.species=&quot;falciparum_3D7&quot;&#39;) # # sc_data_1 = get_data(&quot;pf3d7_single_cell_count&quot;, db) # sc_data_2 = get_data(&quot;pf3d7_single_cell_count_2&quot;, db) # sc_data = merge(x=sc_data_1, y=sc_data_2, by=&#39;transcript_id&#39;, all.x=TRUE) # sc_data = merge(x=id_map, y=sc_data, by=&#39;transcript_id&#39;, all=FALSE) # accession = sc_data$accession # sc_data = subset(sc_data, select = -c(transcript_id, accession)) # rownames(sc_data) = accession # write.csv(sc_data, file=&#39;./other_data/pf_sc_data.csv&#39;) # # dbDisconnect(db) 5.2.2 Processing table In R: library(reshape2) library(ggplot2) library(ggridges) library(rlist) library(cowplot) library(PupillometryR) library(grid) library(gridExtra) prediction &lt;- read.csv(&quot;./data/supplementary_data_4_purf_oob_predictions.csv&quot;, row.names = 1) prediction &lt;- prediction[order(-prediction$oob_score_with_tree_filtering), ] labeled_pos &lt;- rownames(prediction)[prediction$antigen_label == 1] top_200 &lt;- rownames(prediction[prediction$antigen_label == 0, ])[1:200] essential_genes &lt;- read.csv(&quot;./other_data/pf_essential_genes.csv&quot;, header = TRUE, row.names = 1) essential_genes &lt;- rownames(essential_genes)[essential_genes$mis &lt; 0.5] essential_genes &lt;- sapply(essential_genes, function(x) paste0(x, &quot;-p1&quot;)) down_selected &lt;- top_200[top_200 %in% essential_genes] labeled_pos &lt;- sapply(labeled_pos, function(x) substr(x, 1, nchar(x) - 3)) top_200_ &lt;- sapply(top_200, function(x) substr(x, 1, nchar(x) - 3)) # Downloaded from https://www.malariacellatlas.org/data-sets/, or # https://www.malariacellatlas.org/downloads/pf-ss2-set1.zip sc_metadata &lt;- read.csv(&quot;~/Downloads/pf-ss2-set1/pf-ss2-set1-ss2-data.csv&quot;, row.names = 1) # Already normalized sc_data &lt;- read.csv(&quot;~/Downloads/pf-ss2-set1/pf-ss2-set1-ss2-exp.csv&quot;, row.names = 1) rownames(sc_data) &lt;- paste0(rownames(sc_data), &quot;.1&quot;) sc_data_ &lt;- sc_data[rownames(sc_data) %in% top_200_ | rownames(sc_data) %in% labeled_pos, ] stage_order &lt;- c( &quot;sporozoite (oocyst)&quot;, &quot;sporozoite (hemolymph)&quot;, &quot;sporozoite (salivary gland)&quot;, &quot;sporozoite (injected)&quot;, &quot;sporozoite (activated)&quot;, &quot;ring&quot;, &quot;trophozoite&quot;, &quot;schizont&quot;, &quot;gametocyte (developing)&quot;, &quot;gametocyte (male)&quot;, &quot;gametocyte (female)&quot;, &quot;ookinete&quot; ) stage_name &lt;- stage_order stat_res &lt;- list() for (i in 1:nrow(sc_data_)) { gene_stat_res &lt;- c() for (stage in stage_order) { tmp &lt;- as.numeric(sc_data_[i, rownames(sc_metadata[sc_metadata$STAGE_HR == stage, ])]) gene_stat_res &lt;- c(gene_stat_res, paste0( &quot;Prop. cells: &quot;, round(sum(tmp &gt; 0) / length(tmp), 2), &quot;; Median: &quot;, round(median(tmp), 2), &quot;; Mean: &quot;, round(mean(tmp), 2) )) } stat_res &lt;- list.append(stat_res, gene_stat_res) } prox_w_tree_filtering &lt;- read.csv(&quot;./other_data/proximity_values_tree_filtering.csv&quot;, check.names = FALSE) rownames(prox_w_tree_filtering) &lt;- colnames(prox_w_tree_filtering) dist_w_tree_filtering &lt;- 1 - prox_w_tree_filtering dist_w_tree_filtering &lt;- dist_w_tree_filtering[, names(labeled_pos)] colnames(dist_w_tree_filtering) &lt;- names(labeled_pos) # Prepare final table ds &lt;- t(data.frame(stat_res)) rownames(ds) &lt;- sapply(rownames(sc_data_), function(x) paste0(x, &quot;-p1&quot;)) colnames(ds) &lt;- stage_name known_antigens &lt;- sapply(labeled_pos, function(x) paste0(x, &quot;-p1&quot;)) # Add prediction scores prediction &lt;- read.csv(&quot;./data/supplementary_data_4_purf_oob_predictions.csv&quot;, row.names = 1, check.names = FALSE) ds &lt;- merge( x = ds, y = prediction[, c(&quot;oob_score_with_tree_filtering&quot;), drop = FALSE], by = &quot;row.names&quot;, all.x = TRUE ) colnames(ds) &lt;- c(&quot;Protein ID&quot;, stage_name, &quot;Score&quot;) # Add clustering groups load(file = &quot;./rdata/clustering_groups.RData&quot;) ds$Group &lt;- &quot;&quot; ds$Group[ds$`Protein ID` %in% protein_id_1] &lt;- &quot;Group 1&quot; ds$Group[ds$`Protein ID` %in% protein_id_2] &lt;- &quot;Group 2&quot; ds$Group[ds$`Protein ID` %in% protein_id_3] &lt;- &quot;Group 3&quot; ds$Group[ds$`Protein ID` %in% known_antigens] &lt;- &quot;Known antigen&quot; ds$Group[ds$`Protein ID` %in% c( &quot;PF3D7_0304600.1-p1&quot;, &quot;PF3D7_0424100.1-p1&quot;, &quot;PF3D7_0206900.1-p1&quot;, &quot;PF3D7_0209000.1-p1&quot; )] &lt;- &quot;Reference antigen&quot; # Add gene products gene_products &lt;- read.csv(&quot;./other_data/pf3d7_gene_products_v59.csv&quot;) colnames(gene_products) &lt;- c(&quot;Protein ID&quot;, &quot;Gene product&quot;) ds &lt;- merge(x = ds, y = gene_products, by = &quot;Protein ID&quot;, all.x = TRUE) # Add closest reference antigen and the distance ds$`Closest known antigen` &lt;- &quot;&quot; ds$`Closest distance` &lt;- -1 for (i in 1:nrow(ds)) { prot &lt;- ds$`Protein ID`[i] tmp &lt;- dist_w_tree_filtering[prot, ] ds[i, &quot;Closest known antigen&quot;] &lt;- names(tmp)[which.min(tmp)] ds[i, &quot;Closest known antigen&quot;] &lt;- paste0( ds[i, &quot;Closest known antigen&quot;], &quot; (&quot;, gene_products[ gene_products$`Protein ID` == ds[ i, &quot;Closest known antigen&quot; ], &quot;Gene product&quot; ], &quot;)&quot; ) ds[i, &quot;Closest distance&quot;] &lt;- tmp[which.min(tmp)] } # Add essential gene information ds$`Essential` &lt;- &quot;FALSE&quot; ds$`Essential`[ds$`Protein ID` %in% down_selected] &lt;- &quot;TRUE&quot; # Sort based on scores ds &lt;- ds[order(-ds$Score), ] write.csv(ds, file = &quot;./data/supplementary_data_7_antigen_characterization.csv&quot;, row.names = FALSE) 5.2.3 Plotting In R: library(ggplot2) library(gridExtra) library(ggforce) library(reshape) library(stringr) data &lt;- read.csv(&quot;./data/supplementary_data_7_antigen_characterization.csv&quot;, check.names = FALSE) ds_0 &lt;- data[data$Group == &quot;Reference antigen&quot;, 1:13] data &lt;- data[data$Essential == TRUE, ] ds_ &lt;- melt(ds_0, id.vars = &quot;Protein ID&quot;) ds_$`Protein ID` &lt;- factor(ds_$`Protein ID`, levels = c( &quot;PF3D7_0304600.1-p1&quot;, &quot;PF3D7_0424100.1-p1&quot;, &quot;PF3D7_0206900.1-p1&quot;, &quot;PF3D7_0209000.1-p1&quot; )) ds_$prop &lt;- sapply(ds_$value, function(x) as.numeric(str_extract_all(x, &quot;\\\\d+\\\\.\\\\d+|\\\\d+&quot;)[[1]][1])) ds_$median &lt;- sapply(ds_$value, function(x) as.numeric(str_extract_all(x, &quot;\\\\d+\\\\.\\\\d+|\\\\d+&quot;)[[1]][2])) p0 &lt;- ggplot(ds_, aes(x = variable, y = `Protein ID`, color = median)) + geom_point(aes(size = prop)) + scale_y_discrete( limits = rev, breaks = c( &quot;PF3D7_0304600.1-p1&quot;, &quot;PF3D7_0424100.1-p1&quot;, &quot;PF3D7_0206900.1-p1&quot;, &quot;PF3D7_0209000.1-p1&quot; ), labels = c(&quot;CSP&quot;, &quot;RH5&quot;, &quot;MSP5&quot;, &quot;P230&quot;) ) + scale_color_gradient(low = &quot;blue&quot;, high = &quot;red&quot;, limits = c(0, 22)) + scale_size_continuous(range = c(-1, 5), breaks = seq(0.25, 1, 0.25), limits = c(0, 1)) + theme_bw() + theme( panel.grid.major = element_blank(), panel.grid.minor = element_blank(), plot.margin = ggplot2::margin(5, 5, 0, 69, &quot;pt&quot;), plot.title = element_text(hjust = 0.5), axis.title = element_text(colour = &quot;black&quot;), axis.text.x = element_blank(), axis.ticks.x = element_blank(), axis.text.y = element_text(colour = &quot;black&quot;), rect = element_rect(fill = &quot;transparent&quot;), legend.position = &quot;none&quot; ) + xlab(&quot;&quot;) + ylab(&quot;&quot;) + ggtitle(&quot;Reference antigens&quot;) ds_1 &lt;- data[data$Group == &quot;Group 1&quot;, 1:13] ds_ &lt;- melt(ds_1, id.vars = &quot;Protein ID&quot;) ds_$prop &lt;- sapply(ds_$value, function(x) as.numeric(str_extract_all(x, &quot;\\\\d+\\\\.\\\\d+|\\\\d+&quot;)[[1]][1])) ds_$median &lt;- sapply(ds_$value, function(x) as.numeric(str_extract_all(x, &quot;\\\\d+\\\\.\\\\d+|\\\\d+&quot;)[[1]][2])) p1 &lt;- ggplot(ds_, aes(x = variable, y = `Protein ID`, color = median)) + geom_point(aes(size = prop)) + scale_y_discrete(limits = rev) + scale_color_gradient(low = &quot;blue&quot;, high = &quot;red&quot;, limits = c(0, 22)) + scale_size_continuous(range = c(-1, 5), breaks = seq(0.25, 1, 0.25), limits = c(0, 1)) + theme_bw() + theme( panel.grid.major = element_blank(), panel.grid.minor = element_blank(), plot.margin = ggplot2::margin(5, 5, 0, 5, &quot;pt&quot;), plot.title = element_text(hjust = 0.5), axis.title = element_text(colour = &quot;black&quot;), axis.text.x = element_blank(), axis.ticks.x = element_blank(), axis.text.y = element_text(colour = &quot;black&quot;), rect = element_rect(fill = &quot;transparent&quot;), legend.position = &quot;none&quot; ) + xlab(&quot;&quot;) + ylab(&quot;&quot;) + ggtitle(&quot;Group 1 (2 candidates)&quot;) ds_2 &lt;- data[data$Group == &quot;Group 2&quot;, 1:13] ds_ &lt;- melt(ds_2, id.vars = &quot;Protein ID&quot;) ds_$prop &lt;- sapply(ds_$value, function(x) as.numeric(str_extract_all(x, &quot;\\\\d+\\\\.\\\\d+|\\\\d+&quot;)[[1]][1])) ds_$median &lt;- sapply(ds_$value, function(x) as.numeric(str_extract_all(x, &quot;\\\\d+\\\\.\\\\d+|\\\\d+&quot;)[[1]][2])) p2 &lt;- ggplot(ds_, aes(x = variable, y = `Protein ID`, color = median)) + geom_point(aes(size = prop)) + scale_y_discrete(limits = rev) + scale_color_gradient(low = &quot;blue&quot;, high = &quot;red&quot;, limits = c(0, 22)) + scale_size_continuous(range = c(-1, 5), breaks = seq(0.25, 1, 0.25), limits = c(0, 1)) + theme_bw() + theme( panel.grid.major = element_blank(), panel.grid.minor = element_blank(), plot.title = element_text(hjust = 0.5), plot.margin = ggplot2::margin(5, 5, 5, 5, &quot;pt&quot;), axis.title = element_text(colour = &quot;black&quot;), axis.text.x = element_text(colour = &quot;black&quot;, angle = 30, vjust = 1, hjust = 1), axis.text.y = element_text(colour = &quot;black&quot;), rect = element_rect(fill = &quot;transparent&quot;), legend.position = &quot;right&quot; ) + guides( colour = guide_colourbar( title = &quot;Median count&quot;, title.position = &quot;top&quot; ), size = guide_legend( title = &quot;Proportion of cells&quot;, title.position = &quot;top&quot; ) ) + xlab(&quot;&quot;) + ylab(&quot;&quot;) + ggtitle(&quot;Group 2 (26 candidates)&quot;) ds_3 &lt;- data[data$Group == &quot;Group 3&quot;, 1:13] ds_ &lt;- melt(ds_3, id.vars = &quot;Protein ID&quot;) ds_$prop &lt;- sapply(ds_$value, function(x) as.numeric(str_extract_all(x, &quot;\\\\d+\\\\.\\\\d+|\\\\d+&quot;)[[1]][1])) ds_$median &lt;- sapply(ds_$value, function(x) as.numeric(str_extract_all(x, &quot;\\\\d+\\\\.\\\\d+|\\\\d+&quot;)[[1]][2])) p3 &lt;- ggplot(ds_, aes(x = variable, y = `Protein ID`, color = median)) + geom_point(aes(size = prop)) + scale_y_discrete(limits = rev) + scale_color_gradient(low = &quot;blue&quot;, high = &quot;red&quot;, limits = c(0, 22)) + scale_size_continuous(range = c(-1, 5), breaks = seq(0.25, 1, 0.25), limits = c(0, 1)) + theme_bw() + theme( panel.grid.major = element_blank(), panel.grid.minor = element_blank(), plot.margin = ggplot2::margin(5, 5, 5, 5, &quot;pt&quot;), plot.title = element_text(hjust = 0.5), axis.title = element_text(colour = &quot;black&quot;), axis.text.x = element_text(colour = &quot;black&quot;, angle = 30, vjust = 1, hjust = 1), axis.text.y = element_text(colour = &quot;black&quot;), rect = element_rect(fill = &quot;transparent&quot;), legend.background = element_blank(), legend.key = element_blank(), legend.position = &quot;none&quot; ) + xlab(&quot;&quot;) + ylab(&quot;&quot;) + ggtitle(&quot;Group 3 (14 candidates)&quot;) Final plot p_combined &lt;- plot_grid(plot_grid(p0, p1, p3, ncol = 1, rel_heights = c(0.2, 0.15, 0.65)), p2, nrow = 1, rel_widths = c(0.3, 0.4) ) p_combined sessionInfo() ## R version 4.2.3 (2023-03-15) ## Platform: x86_64-apple-darwin17.0 (64-bit) ## Running under: macOS Big Sur ... 10.16 ## ## Matrix products: default ## BLAS: /Library/Frameworks/R.framework/Versions/4.2/Resources/lib/libRblas.0.dylib ## LAPACK: /Library/Frameworks/R.framework/Versions/4.2/Resources/lib/libRlapack.dylib ## ## locale: ## [1] en_US.UTF-8/en_US.UTF-8/en_US.UTF-8/C/en_US.UTF-8/en_US.UTF-8 ## ## attached base packages: ## [1] grid stats graphics grDevices utils datasets methods ## [8] base ## ## other attached packages: ## [1] stringr_1.4.1 PupillometryR_0.0.4 rlang_1.1.0 ## [4] dplyr_1.0.9 rlist_0.4.6.2 ggridges_0.5.3 ## [7] reshape2_1.4.4 DBI_1.1.3 RMariaDB_1.2.2 ## [10] cowplot_1.1.1 reshape_0.8.9 ggforce_0.3.4 ## [13] shadowtext_0.1.2 gridExtra_2.3 ggplot2_3.4.2 ## ## loaded via a namespace (and not attached): ## [1] Rcpp_1.0.9 assertthat_0.2.1 digest_0.6.29 utf8_1.2.2 ## [5] R6_2.5.1 plyr_1.8.7 evaluate_0.16 highr_0.9 ## [9] pillar_1.8.1 data.table_1.14.2 rstudioapi_0.14 jquerylib_0.1.4 ## [13] R.utils_2.12.0 R.oo_1.25.0 rmarkdown_2.16 styler_1.8.0 ## [17] polyclip_1.10-0 bit_4.0.4 munsell_0.5.0 compiler_4.2.3 ## [21] xfun_0.32 pkgconfig_2.0.3 htmltools_0.5.3 tidyselect_1.1.2 ## [25] tibble_3.1.8 bookdown_0.28 codetools_0.2-19 fansi_1.0.3 ## [29] withr_2.5.0 MASS_7.3-58.2 R.methodsS3_1.8.2 jsonlite_1.8.0 ## [33] gtable_0.3.0 lifecycle_1.0.3 magrittr_2.0.3 scales_1.2.1 ## [37] cli_3.6.1 stringi_1.7.8 cachem_1.0.6 farver_2.1.1 ## [41] bslib_0.4.0 ellipsis_0.3.2 generics_0.1.3 vctrs_0.6.2 ## [45] tools_4.2.3 bit64_4.0.5 R.cache_0.16.0 glue_1.6.2 ## [49] tweenr_2.0.1 purrr_0.3.4 hms_1.1.2 fastmap_1.1.0 ## [53] yaml_2.3.5 colorspace_2.0-3 knitr_1.40 sass_0.4.2 References "],["id_06_summary_of_candidates.html", "Section 6 Summary of candidates", " Section 6 Summary of candidates The table provides a summary of 52 known antigens (including 4 reference antigens) and the top 200 antigen candidates. It includes columns for protein IDs, probability scores, antigen/candidate groups, gene products, closest known antigens, distance to the closest antigens, gene essentiality, and single-cell gene expression at various life stages. You can easily visualize the corresponding values with colored bars for probability scores and gene expressions. Grey bars indicate probability scores. Red, blue, and light green bars represent the proportion of cells expressing the gene, median expression level, and mean expression level of the cell population, respectively. To view columns on the right, scroll right for more information. To filter columns according to specific criteria, click on the white boxes under the headers to set thresholds. You can also sort values in ascending or descending order by clicking on the arrows next to the header. "],["references.html", "References", " References "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
